'use strict';

var contentTypePrimitives = require('@xmtp/content-type-primitives');
var proto = require('@xmtp/proto');

const ContentTypeReply = new contentTypePrimitives.ContentTypeId({
    authorityId: "xmtp.org",
    typeId: "reply",
    versionMajor: 1,
    versionMinor: 0,
});
class ReplyCodec {
    get contentType() {
        return ContentTypeReply;
    }
    encode(content, registry) {
        const codec = registry.codecFor(content.contentType);
        if (!codec) {
            throw new Error(`missing codec for content type "${content.contentType.toString()}"`);
        }
        const encodedContent = codec.encode(content.content, registry);
        const bytes = proto.content.EncodedContent.encode(encodedContent).finish();
        const parameters = {
            // TODO: cut when we're certain no one is looking for "contentType" here.
            contentType: content.contentType.toString(),
            reference: content.reference,
        };
        // add referenceInboxId if it's present
        if (content.referenceInboxId) {
            parameters.referenceInboxId = content.referenceInboxId;
        }
        return {
            type: this.contentType,
            parameters,
            content: bytes,
        };
    }
    decode(content, registry) {
        const decodedContent = proto.content.EncodedContent.decode(content.content);
        if (!decodedContent.type) {
            throw new Error("missing content type");
        }
        const contentType = new contentTypePrimitives.ContentTypeId(decodedContent.type);
        const codec = registry.codecFor(contentType);
        if (!codec) {
            throw new Error(`missing codec for content type "${contentType.toString()}"`);
        }
        return {
            reference: content.parameters.reference,
            referenceInboxId: content.parameters.referenceInboxId,
            contentType,
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            content: codec.decode(decodedContent, registry),
        };
    }
    fallback(content) {
        if (typeof content.content === "string") {
            return `Replied with “${content.content}” to an earlier message`;
        }
        return "Replied to an earlier message";
    }
    shouldPush() {
        return true;
    }
}

exports.ContentTypeReply = ContentTypeReply;
exports.ReplyCodec = ReplyCodec;
//# sourceMappingURL=index.cjs.map
