import { ContentTypeId } from '@xmtp/content-type-primitives';
import { content } from '@xmtp/proto';

const ContentTypeReply = new ContentTypeId({
    authorityId: "xmtp.org",
    typeId: "reply",
    versionMajor: 1,
    versionMinor: 0,
});
class ReplyCodec {
    get contentType() {
        return ContentTypeReply;
    }
    encode(content$1, registry) {
        const codec = registry.codecFor(content$1.contentType);
        if (!codec) {
            throw new Error(`missing codec for content type "${content$1.contentType.toString()}"`);
        }
        const encodedContent = codec.encode(content$1.content, registry);
        const bytes = content.EncodedContent.encode(encodedContent).finish();
        const parameters = {
            // TODO: cut when we're certain no one is looking for "contentType" here.
            contentType: content$1.contentType.toString(),
            reference: content$1.reference,
        };
        // add referenceInboxId if it's present
        if (content$1.referenceInboxId) {
            parameters.referenceInboxId = content$1.referenceInboxId;
        }
        return {
            type: this.contentType,
            parameters,
            content: bytes,
        };
    }
    decode(content$1, registry) {
        const decodedContent = content.EncodedContent.decode(content$1.content);
        if (!decodedContent.type) {
            throw new Error("missing content type");
        }
        const contentType = new ContentTypeId(decodedContent.type);
        const codec = registry.codecFor(contentType);
        if (!codec) {
            throw new Error(`missing codec for content type "${contentType.toString()}"`);
        }
        return {
            reference: content$1.parameters.reference,
            referenceInboxId: content$1.parameters.referenceInboxId,
            contentType,
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            content: codec.decode(decodedContent, registry),
        };
    }
    fallback(content) {
        if (typeof content.content === "string") {
            return `Replied with “${content.content}” to an earlier message`;
        }
        return "Replied to an earlier message";
    }
    shouldPush() {
        return true;
    }
}

export { ContentTypeReply, ReplyCodec };
//# sourceMappingURL=index.js.map
