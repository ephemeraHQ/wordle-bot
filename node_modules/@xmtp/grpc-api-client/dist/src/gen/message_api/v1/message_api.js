// @generated by protobuf-ts 2.9.1
// @generated from protobuf file "message_api/v1/message_api.proto" (package "xmtp.message_api.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Sort direction
 *
 * @generated from protobuf enum xmtp.message_api.v1.SortDirection
 */
export var SortDirection;
(function (SortDirection) {
    /**
     * @generated from protobuf enum value: SORT_DIRECTION_UNSPECIFIED = 0;
     */
    SortDirection[SortDirection["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    /**
     * @generated from protobuf enum value: SORT_DIRECTION_ASCENDING = 1;
     */
    SortDirection[SortDirection["ASCENDING"] = 1] = "ASCENDING";
    /**
     * @generated from protobuf enum value: SORT_DIRECTION_DESCENDING = 2;
     */
    SortDirection[SortDirection["DESCENDING"] = 2] = "DESCENDING";
})(SortDirection || (SortDirection = {}));
// @generated message type with reflection information, may provide speed optimized methods
class IndexCursor$Type extends MessageType {
    constructor() {
        super("xmtp.message_api.v1.IndexCursor", [
            { no: 1, name: "digest", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            {
                no: 2,
                name: "sender_time_ns",
                kind: "scalar",
                T: 4 /*ScalarType.UINT64*/,
                L: 0 /*LongType.BIGINT*/,
            },
        ]);
    }
    create(value) {
        const message = { digest: new Uint8Array(0), senderTimeNs: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
            enumerable: false,
            value: this,
        });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes digest */ 1:
                    message.digest = reader.bytes();
                    break;
                case /* uint64 sender_time_ns */ 2:
                    message.senderTimeNs = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes digest = 1; */
        if (message.digest.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.digest);
        /* uint64 sender_time_ns = 2; */
        if (message.senderTimeNs !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.senderTimeNs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.IndexCursor
 */
export const IndexCursor = new IndexCursor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cursor$Type extends MessageType {
    constructor() {
        super("xmtp.message_api.v1.Cursor", [
            {
                no: 1,
                name: "index",
                kind: "message",
                oneof: "cursor",
                T: () => IndexCursor,
            },
        ]);
    }
    create(value) {
        const message = { cursor: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
            enumerable: false,
            value: this,
        });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xmtp.message_api.v1.IndexCursor index */ 1:
                    message.cursor = {
                        oneofKind: "index",
                        index: IndexCursor.internalBinaryRead(reader, reader.uint32(), options, message.cursor.index),
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* xmtp.message_api.v1.IndexCursor index = 1; */
        if (message.cursor.oneofKind === "index")
            IndexCursor.internalBinaryWrite(message.cursor.index, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.Cursor
 */
export const Cursor = new Cursor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PagingInfo$Type extends MessageType {
    constructor() {
        super("xmtp.message_api.v1.PagingInfo", [
            { no: 1, name: "limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "cursor", kind: "message", T: () => Cursor },
            {
                no: 3,
                name: "direction",
                kind: "enum",
                T: () => [
                    "xmtp.message_api.v1.SortDirection",
                    SortDirection,
                    "SORT_DIRECTION_",
                ],
            },
        ]);
    }
    create(value) {
        const message = { limit: 0, direction: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
            enumerable: false,
            value: this,
        });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 limit */ 1:
                    message.limit = reader.uint32();
                    break;
                case /* xmtp.message_api.v1.Cursor cursor */ 2:
                    message.cursor = Cursor.internalBinaryRead(reader, reader.uint32(), options, message.cursor);
                    break;
                case /* xmtp.message_api.v1.SortDirection direction */ 3:
                    message.direction = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* uint32 limit = 1; */
        if (message.limit !== 0)
            writer.tag(1, WireType.Varint).uint32(message.limit);
        /* xmtp.message_api.v1.Cursor cursor = 2; */
        if (message.cursor)
            Cursor.internalBinaryWrite(message.cursor, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* xmtp.message_api.v1.SortDirection direction = 3; */
        if (message.direction !== 0)
            writer.tag(3, WireType.Varint).int32(message.direction);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.PagingInfo
 */
export const PagingInfo = new PagingInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Envelope$Type extends MessageType {
    constructor() {
        super("xmtp.message_api.v1.Envelope", [
            {
                no: 1,
                name: "content_topic",
                kind: "scalar",
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 2,
                name: "timestamp_ns",
                kind: "scalar",
                T: 4 /*ScalarType.UINT64*/,
                L: 0 /*LongType.BIGINT*/,
            },
            { no: 3, name: "message", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
        ]);
    }
    create(value) {
        const message = {
            contentTopic: "",
            timestampNs: 0n,
            message: new Uint8Array(0),
        };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
            enumerable: false,
            value: this,
        });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string content_topic */ 1:
                    message.contentTopic = reader.string();
                    break;
                case /* uint64 timestamp_ns */ 2:
                    message.timestampNs = reader.uint64().toBigInt();
                    break;
                case /* bytes message */ 3:
                    message.message = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string content_topic = 1; */
        if (message.contentTopic !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.contentTopic);
        /* uint64 timestamp_ns = 2; */
        if (message.timestampNs !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.timestampNs);
        /* bytes message = 3; */
        if (message.message.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.Envelope
 */
export const Envelope = new Envelope$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishRequest$Type extends MessageType {
    constructor() {
        super("xmtp.message_api.v1.PublishRequest", [
            {
                no: 1,
                name: "envelopes",
                kind: "message",
                repeat: 1 /*RepeatType.PACKED*/,
                T: () => Envelope,
            },
        ]);
    }
    create(value) {
        const message = { envelopes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
            enumerable: false,
            value: this,
        });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.message_api.v1.Envelope envelopes */ 1:
                    message.envelopes.push(Envelope.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated xmtp.message_api.v1.Envelope envelopes = 1; */
        for (let i = 0; i < message.envelopes.length; i++)
            Envelope.internalBinaryWrite(message.envelopes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.PublishRequest
 */
export const PublishRequest = new PublishRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishResponse$Type extends MessageType {
    constructor() {
        super("xmtp.message_api.v1.PublishResponse", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
            enumerable: false,
            value: this,
        });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.PublishResponse
 */
export const PublishResponse = new PublishResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeRequest$Type extends MessageType {
    constructor() {
        super("xmtp.message_api.v1.SubscribeRequest", [
            {
                no: 1,
                name: "content_topics",
                kind: "scalar",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 9 /*ScalarType.STRING*/,
            },
        ]);
    }
    create(value) {
        const message = { contentTopics: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
            enumerable: false,
            value: this,
        });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string content_topics */ 1:
                    message.contentTopics.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated string content_topics = 1; */
        for (let i = 0; i < message.contentTopics.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.contentTopics[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.SubscribeRequest
 */
export const SubscribeRequest = new SubscribeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeAllRequest$Type extends MessageType {
    constructor() {
        super("xmtp.message_api.v1.SubscribeAllRequest", []);
    }
    create(value) {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
            enumerable: false,
            value: this,
        });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        return target ?? this.create();
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.SubscribeAllRequest
 */
export const SubscribeAllRequest = new SubscribeAllRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryRequest$Type extends MessageType {
    constructor() {
        super("xmtp.message_api.v1.QueryRequest", [
            {
                no: 1,
                name: "content_topics",
                kind: "scalar",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 2,
                name: "start_time_ns",
                kind: "scalar",
                T: 4 /*ScalarType.UINT64*/,
                L: 0 /*LongType.BIGINT*/,
            },
            {
                no: 3,
                name: "end_time_ns",
                kind: "scalar",
                T: 4 /*ScalarType.UINT64*/,
                L: 0 /*LongType.BIGINT*/,
            },
            { no: 4, name: "paging_info", kind: "message", T: () => PagingInfo },
        ]);
    }
    create(value) {
        const message = { contentTopics: [], startTimeNs: 0n, endTimeNs: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
            enumerable: false,
            value: this,
        });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string content_topics */ 1:
                    message.contentTopics.push(reader.string());
                    break;
                case /* uint64 start_time_ns */ 2:
                    message.startTimeNs = reader.uint64().toBigInt();
                    break;
                case /* uint64 end_time_ns */ 3:
                    message.endTimeNs = reader.uint64().toBigInt();
                    break;
                case /* xmtp.message_api.v1.PagingInfo paging_info */ 4:
                    message.pagingInfo = PagingInfo.internalBinaryRead(reader, reader.uint32(), options, message.pagingInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated string content_topics = 1; */
        for (let i = 0; i < message.contentTopics.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.contentTopics[i]);
        /* uint64 start_time_ns = 2; */
        if (message.startTimeNs !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.startTimeNs);
        /* uint64 end_time_ns = 3; */
        if (message.endTimeNs !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.endTimeNs);
        /* xmtp.message_api.v1.PagingInfo paging_info = 4; */
        if (message.pagingInfo)
            PagingInfo.internalBinaryWrite(message.pagingInfo, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.QueryRequest
 */
export const QueryRequest = new QueryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryResponse$Type extends MessageType {
    constructor() {
        super("xmtp.message_api.v1.QueryResponse", [
            {
                no: 1,
                name: "envelopes",
                kind: "message",
                repeat: 1 /*RepeatType.PACKED*/,
                T: () => Envelope,
            },
            { no: 2, name: "paging_info", kind: "message", T: () => PagingInfo },
        ]);
    }
    create(value) {
        const message = { envelopes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
            enumerable: false,
            value: this,
        });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.message_api.v1.Envelope envelopes */ 1:
                    message.envelopes.push(Envelope.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* xmtp.message_api.v1.PagingInfo paging_info */ 2:
                    message.pagingInfo = PagingInfo.internalBinaryRead(reader, reader.uint32(), options, message.pagingInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated xmtp.message_api.v1.Envelope envelopes = 1; */
        for (let i = 0; i < message.envelopes.length; i++)
            Envelope.internalBinaryWrite(message.envelopes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* xmtp.message_api.v1.PagingInfo paging_info = 2; */
        if (message.pagingInfo)
            PagingInfo.internalBinaryWrite(message.pagingInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.QueryResponse
 */
export const QueryResponse = new QueryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BatchQueryRequest$Type extends MessageType {
    constructor() {
        super("xmtp.message_api.v1.BatchQueryRequest", [
            {
                no: 1,
                name: "requests",
                kind: "message",
                repeat: 1 /*RepeatType.PACKED*/,
                T: () => QueryRequest,
            },
        ]);
    }
    create(value) {
        const message = { requests: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
            enumerable: false,
            value: this,
        });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.message_api.v1.QueryRequest requests */ 1:
                    message.requests.push(QueryRequest.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated xmtp.message_api.v1.QueryRequest requests = 1; */
        for (let i = 0; i < message.requests.length; i++)
            QueryRequest.internalBinaryWrite(message.requests[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.BatchQueryRequest
 */
export const BatchQueryRequest = new BatchQueryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BatchQueryResponse$Type extends MessageType {
    constructor() {
        super("xmtp.message_api.v1.BatchQueryResponse", [
            {
                no: 1,
                name: "responses",
                kind: "message",
                repeat: 1 /*RepeatType.PACKED*/,
                T: () => QueryResponse,
            },
        ]);
    }
    create(value) {
        const message = { responses: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
            enumerable: false,
            value: this,
        });
        if (value !== undefined)
            reflectionMergePartial(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.message_api.v1.QueryResponse responses */ 1:
                    message.responses.push(QueryResponse.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated xmtp.message_api.v1.QueryResponse responses = 1; */
        for (let i = 0; i < message.responses.length; i++)
            QueryResponse.internalBinaryWrite(message.responses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.BatchQueryResponse
 */
export const BatchQueryResponse = new BatchQueryResponse$Type();
/**
 * @generated ServiceType for protobuf service xmtp.message_api.v1.MessageApi
 */
export const MessageApi = new ServiceType("xmtp.message_api.v1.MessageApi", [
    {
        name: "Publish",
        options: { "google.api.http": { post: "/message/v1/publish", body: "*" } },
        I: PublishRequest,
        O: PublishResponse,
    },
    {
        name: "Subscribe",
        serverStreaming: true,
        options: {
            "google.api.http": { post: "/message/v1/subscribe", body: "*" },
        },
        I: SubscribeRequest,
        O: Envelope,
    },
    {
        name: "Subscribe2",
        serverStreaming: true,
        clientStreaming: true,
        options: {},
        I: SubscribeRequest,
        O: Envelope,
    },
    {
        name: "SubscribeAll",
        serverStreaming: true,
        options: {
            "google.api.http": { post: "/message/v1/subscribe-all", body: "*" },
        },
        I: SubscribeAllRequest,
        O: Envelope,
    },
    {
        name: "Query",
        options: { "google.api.http": { post: "/message/v1/query", body: "*" } },
        I: QueryRequest,
        O: QueryResponse,
    },
    {
        name: "BatchQuery",
        options: {
            "google.api.http": { post: "/message/v1/batch-query", body: "*" },
        },
        I: BatchQueryRequest,
        O: BatchQueryResponse,
    },
]);
//# sourceMappingURL=message_api.js.map