import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * This is based off of the go-waku Index type, but with the
 * receiverTime and pubsubTopic removed for simplicity.
 * Both removed fields are optional
 *
 * @generated from protobuf message xmtp.message_api.v1.IndexCursor
 */
export interface IndexCursor {
    /**
     * @generated from protobuf field: bytes digest = 1;
     */
    digest: Uint8Array;
    /**
     * @generated from protobuf field: uint64 sender_time_ns = 2;
     */
    senderTimeNs: bigint;
}
/**
 * Wrapper for potentially multiple types of cursor
 *
 * @generated from protobuf message xmtp.message_api.v1.Cursor
 */
export interface Cursor {
    /**
     * @generated from protobuf oneof: cursor
     */
    cursor: {
        oneofKind: "index";
        /**
         * @generated from protobuf field: xmtp.message_api.v1.IndexCursor index = 1;
         */
        index: IndexCursor;
    } | {
        oneofKind: undefined;
    };
}
/**
 * This is based off of the go-waku PagingInfo struct, but with the direction
 * changed to our SortDirection enum format
 *
 * @generated from protobuf message xmtp.message_api.v1.PagingInfo
 */
export interface PagingInfo {
    /**
     * Note: this is a uint32, while go-waku's pageSize is a uint64
     *
     * @generated from protobuf field: uint32 limit = 1;
     */
    limit: number;
    /**
     * @generated from protobuf field: xmtp.message_api.v1.Cursor cursor = 2;
     */
    cursor?: Cursor;
    /**
     * @generated from protobuf field: xmtp.message_api.v1.SortDirection direction = 3;
     */
    direction: SortDirection;
}
/**
 * Envelope encapsulates a message while in transit.
 *
 * @generated from protobuf message xmtp.message_api.v1.Envelope
 */
export interface Envelope {
    /**
     * The topic the message belongs to,
     * If the message includes the topic as well
     * it MUST be the same as the topic in the envelope.
     *
     * @generated from protobuf field: string content_topic = 1;
     */
    contentTopic: string;
    /**
     * Message creation timestamp
     * If the message includes the timestamp as well
     * it MUST be equivalent to the timestamp in the envelope.
     *
     * @generated from protobuf field: uint64 timestamp_ns = 2;
     */
    timestampNs: bigint;
    /**
     * @generated from protobuf field: bytes message = 3;
     */
    message: Uint8Array;
}
/**
 * Publish
 *
 * @generated from protobuf message xmtp.message_api.v1.PublishRequest
 */
export interface PublishRequest {
    /**
     * @generated from protobuf field: repeated xmtp.message_api.v1.Envelope envelopes = 1;
     */
    envelopes: Envelope[];
}
/**
 * Empty message as a response for Publish
 *
 * @generated from protobuf message xmtp.message_api.v1.PublishResponse
 */
export interface PublishResponse {
}
/**
 * Subscribe
 *
 * @generated from protobuf message xmtp.message_api.v1.SubscribeRequest
 */
export interface SubscribeRequest {
    /**
     * @generated from protobuf field: repeated string content_topics = 1;
     */
    contentTopics: string[];
}
/**
 * SubscribeAll
 *
 * @generated from protobuf message xmtp.message_api.v1.SubscribeAllRequest
 */
export interface SubscribeAllRequest {
}
/**
 * Query
 *
 * @generated from protobuf message xmtp.message_api.v1.QueryRequest
 */
export interface QueryRequest {
    /**
     * @generated from protobuf field: repeated string content_topics = 1;
     */
    contentTopics: string[];
    /**
     * @generated from protobuf field: uint64 start_time_ns = 2;
     */
    startTimeNs: bigint;
    /**
     * @generated from protobuf field: uint64 end_time_ns = 3;
     */
    endTimeNs: bigint;
    /**
     * @generated from protobuf field: xmtp.message_api.v1.PagingInfo paging_info = 4;
     */
    pagingInfo?: PagingInfo;
}
/**
 * The response, containing envelopes, for a query
 *
 * @generated from protobuf message xmtp.message_api.v1.QueryResponse
 */
export interface QueryResponse {
    /**
     * @generated from protobuf field: repeated xmtp.message_api.v1.Envelope envelopes = 1;
     */
    envelopes: Envelope[];
    /**
     * @generated from protobuf field: xmtp.message_api.v1.PagingInfo paging_info = 2;
     */
    pagingInfo?: PagingInfo;
}
/**
 * BatchQuery
 *
 * @generated from protobuf message xmtp.message_api.v1.BatchQueryRequest
 */
export interface BatchQueryRequest {
    /**
     * @generated from protobuf field: repeated xmtp.message_api.v1.QueryRequest requests = 1;
     */
    requests: QueryRequest[];
}
/**
 * Response containing a list of QueryResponse messages
 *
 * @generated from protobuf message xmtp.message_api.v1.BatchQueryResponse
 */
export interface BatchQueryResponse {
    /**
     * @generated from protobuf field: repeated xmtp.message_api.v1.QueryResponse responses = 1;
     */
    responses: QueryResponse[];
}
/**
 * Sort direction
 *
 * @generated from protobuf enum xmtp.message_api.v1.SortDirection
 */
export declare enum SortDirection {
    /**
     * @generated from protobuf enum value: SORT_DIRECTION_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: SORT_DIRECTION_ASCENDING = 1;
     */
    ASCENDING = 1,
    /**
     * @generated from protobuf enum value: SORT_DIRECTION_DESCENDING = 2;
     */
    DESCENDING = 2
}
declare class IndexCursor$Type extends MessageType<IndexCursor> {
    constructor();
    create(value?: PartialMessage<IndexCursor>): IndexCursor;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IndexCursor): IndexCursor;
    internalBinaryWrite(message: IndexCursor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.IndexCursor
 */
export declare const IndexCursor: IndexCursor$Type;
declare class Cursor$Type extends MessageType<Cursor> {
    constructor();
    create(value?: PartialMessage<Cursor>): Cursor;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cursor): Cursor;
    internalBinaryWrite(message: Cursor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.Cursor
 */
export declare const Cursor: Cursor$Type;
declare class PagingInfo$Type extends MessageType<PagingInfo> {
    constructor();
    create(value?: PartialMessage<PagingInfo>): PagingInfo;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PagingInfo): PagingInfo;
    internalBinaryWrite(message: PagingInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.PagingInfo
 */
export declare const PagingInfo: PagingInfo$Type;
declare class Envelope$Type extends MessageType<Envelope> {
    constructor();
    create(value?: PartialMessage<Envelope>): Envelope;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Envelope): Envelope;
    internalBinaryWrite(message: Envelope, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.Envelope
 */
export declare const Envelope: Envelope$Type;
declare class PublishRequest$Type extends MessageType<PublishRequest> {
    constructor();
    create(value?: PartialMessage<PublishRequest>): PublishRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishRequest): PublishRequest;
    internalBinaryWrite(message: PublishRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.PublishRequest
 */
export declare const PublishRequest: PublishRequest$Type;
declare class PublishResponse$Type extends MessageType<PublishResponse> {
    constructor();
    create(value?: PartialMessage<PublishResponse>): PublishResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishResponse): PublishResponse;
    internalBinaryWrite(message: PublishResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.PublishResponse
 */
export declare const PublishResponse: PublishResponse$Type;
declare class SubscribeRequest$Type extends MessageType<SubscribeRequest> {
    constructor();
    create(value?: PartialMessage<SubscribeRequest>): SubscribeRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeRequest): SubscribeRequest;
    internalBinaryWrite(message: SubscribeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.SubscribeRequest
 */
export declare const SubscribeRequest: SubscribeRequest$Type;
declare class SubscribeAllRequest$Type extends MessageType<SubscribeAllRequest> {
    constructor();
    create(value?: PartialMessage<SubscribeAllRequest>): SubscribeAllRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeAllRequest): SubscribeAllRequest;
    internalBinaryWrite(message: SubscribeAllRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.SubscribeAllRequest
 */
export declare const SubscribeAllRequest: SubscribeAllRequest$Type;
declare class QueryRequest$Type extends MessageType<QueryRequest> {
    constructor();
    create(value?: PartialMessage<QueryRequest>): QueryRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryRequest): QueryRequest;
    internalBinaryWrite(message: QueryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.QueryRequest
 */
export declare const QueryRequest: QueryRequest$Type;
declare class QueryResponse$Type extends MessageType<QueryResponse> {
    constructor();
    create(value?: PartialMessage<QueryResponse>): QueryResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryResponse): QueryResponse;
    internalBinaryWrite(message: QueryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.QueryResponse
 */
export declare const QueryResponse: QueryResponse$Type;
declare class BatchQueryRequest$Type extends MessageType<BatchQueryRequest> {
    constructor();
    create(value?: PartialMessage<BatchQueryRequest>): BatchQueryRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BatchQueryRequest): BatchQueryRequest;
    internalBinaryWrite(message: BatchQueryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.BatchQueryRequest
 */
export declare const BatchQueryRequest: BatchQueryRequest$Type;
declare class BatchQueryResponse$Type extends MessageType<BatchQueryResponse> {
    constructor();
    create(value?: PartialMessage<BatchQueryResponse>): BatchQueryResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BatchQueryResponse): BatchQueryResponse;
    internalBinaryWrite(message: BatchQueryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.BatchQueryResponse
 */
export declare const BatchQueryResponse: BatchQueryResponse$Type;
/**
 * @generated ServiceType for protobuf service xmtp.message_api.v1.MessageApi
 */
export declare const MessageApi: ServiceType;
export {};
//# sourceMappingURL=message_api.d.ts.map