'use strict';

require('dotenv/config');
var nodeSdk = require('@xmtp/node-sdk');
var fs = require('fs/promises');
var path = require('path');
var contentTypeText = require('@xmtp/content-type-text');
var contentTypeReply = require('@xmtp/content-type-reply');
var contentTypeRemoteAttachment = require('@xmtp/content-type-remote-attachment');
var contentTypeReaction = require('@xmtp/content-type-reaction');
var xmtpJs = require('@xmtp/xmtp-js');
var ethers = require('ethers');
var fs$1 = require('fs');
var viem = require('viem');
var accounts = require('viem/accounts');
var chains = require('viem/chains');
var grpcApiClient = require('@xmtp/grpc-api-client');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var path__namespace = /*#__PURE__*/_interopNamespaceDefault(path);
var fs__namespace = /*#__PURE__*/_interopNamespaceDefault(fs$1);

/*
  Issue:
  There are many incostencies with casing. Parsing everything with lowerCase
  is not ideal, but it's the best we can do for now.
*/
function mapUsernamesToInboxId(usernames, users) {
    return usernames
        .map((username) => {
        return users.find((user) => user.username === username.replace("@", ""));
    })
        .filter((user) => user !== null);
}
// Define a list of fake users with usernames and addresses
const fakeUsers = [
    {
        username: "alix",
        address: "0x3a044b218BaE80E5b9E16609443A192129A67BeA",
        inboxId: "da3750159ea7541dda1e271076a3663d8c14576ab85bbd3416d45c9f19e35cbc",
        accountAddresses: ["0x3a044b218BaE80E5b9E16609443A192129A67BeA"],
        installationIds: [],
        fake: true,
    },
    {
        username: "eva",
        address: "0xeAc10D864802fCcfe897E3957776634D1AE006B2",
        inboxId: "6196afe3fd16c276113b0e4fc913745c39af337ea869fb49a2835201874de49c",
        accountAddresses: ["0xeAc10D864802fCcfe897E3957776634D1AE006B2"],
        installationIds: [],
        fake: true,
    },
    {
        username: "bo",
        address: "0xbc3246461ab5e1682baE48fa95172CDf0689201a",
        inboxId: "8d833f5419cbbfda027813e1fcd1db86c9ec320fd22fbe182883c47a7f34adc0",
        accountAddresses: ["0xbc3246461ab5e1682baE48fa95172CDf0689201a"],
        installationIds: [],
        fake: true,
    },
];
function populateUsernames(members, clientAddress, senderInboxId) {
    //v2
    if (!members)
        members = fakeUsers;
    // Map existing members to the required format
    const mappedMembers = members.map((member) => ({
        username: member.username?.toLowerCase(),
        accountAddresses: member.accountAddresses.map((address) => address.toLowerCase()),
        address: member?.accountAddresses?.[0].toLowerCase(),
        inboxId: member?.inboxId?.toLowerCase(),
    }));
    for (let member of mappedMembers) {
        if (member?.inboxId?.toLowerCase() === senderInboxId?.toLowerCase()) {
            member.username = "me";
        }
        else if (member?.address?.toLowerCase() === clientAddress?.toLowerCase()) {
            member.username = "bot";
        }
        else if (member.address.toLowerCase() ===
            "0xc16c47ea4a9f6ba81664f7623245b2c7429c71dc") {
            member.username = "fabridesktop";
        }
        else {
            const fakeUser = fakeUsers.find((user) => user.address.toLowerCase() === member.address.toLowerCase());
            if (fakeUser) {
                member.username = fakeUser.username?.toLowerCase();
                member.address = member.address?.toLowerCase();
            }
        }
    }
    const remainingUsers = fakeUsers.filter((fakeUser) => !mappedMembers.some((member) => member.address.toLowerCase() === fakeUser.address.toLowerCase()));
    remainingUsers.forEach((user) => {
        mappedMembers.push({
            username: user.username?.toLowerCase(),
            accountAddresses: [user.address?.toLowerCase()],
            address: user.address?.toLowerCase(),
            inboxId: user.inboxId?.toLowerCase(),
            installationIds: user.installationIds,
            fake: user.fake,
        });
    });
    return mappedMembers;
}

function parseCommand(content, commands, members) {
    let contentReturn;
    //If is command of other bot. MULTIBOT
    const firstWord = content?.split(" ")[0];
    if ((firstWord.startsWith("/") && !firstWord.includes("@")) ||
        (firstWord.startsWith("/") && firstWord.includes("@"))) {
        const extractedValues = extractCommandValues(content, commands ?? [], members ?? []);
        contentReturn = {
            content: content,
            ...extractedValues,
        };
    }
    else {
        contentReturn = {
            content: content,
        };
    }
    return contentReturn;
}
function extractCommandValues(content, commands, members) {
    const defaultResult = {
        command: undefined,
        params: {},
    };
    try {
        if (typeof content !== "string")
            return defaultResult;
        // Replace all "“" and "”" with "'" and '"'
        content = content.replaceAll("“", '"').replaceAll("”", '"');
        const parts = content.match(/[^\s"']+|"([^"]*)"|'([^']*)'|`([^`]*)`/g);
        if (!parts)
            return defaultResult;
        let commandName = parts[0].startsWith("/") ? parts[0].slice(1) : parts[0];
        let commandConfig;
        for (const group of commands) {
            commandConfig = group.commands.find((cmd) => cmd.command.startsWith(`/${commandName}`));
            if (commandConfig)
                break;
        }
        if (!commandConfig)
            return defaultResult;
        const values = {
            command: commandName,
            params: {},
        };
        const expectedParams = commandConfig.params || {};
        const usedIndices = new Set();
        Object.keys(expectedParams).forEach((param) => {
            const { values: possibleValues = [], default: defaultValue, type = "string", } = expectedParams[param];
            let valueFound = false;
            // Handle string type with no possible values
            if (type === "string" && possibleValues.length === 0) {
                const stringIndex = parts.findIndex((part, idx) => !usedIndices.has(idx) && idx > 0);
                if (stringIndex !== -1) {
                    values.params[param] = parts[stringIndex];
                    usedIndices.add(stringIndex);
                    valueFound = true;
                }
            }
            else if (type === "quoted") {
                const quotedIndex = parts.findIndex((part, idx) => /^["'`].*["'`]$/.test(part) && !usedIndices.has(idx));
                if (quotedIndex !== -1) {
                    values.params[param] = parts[quotedIndex].slice(1, -1);
                    usedIndices.add(quotedIndex);
                    valueFound = true;
                }
            }
            else if (type === "prompt") {
                values.params[param] = parts.slice(1).join(" ");
                valueFound = true;
            }
            else if (type === "address") {
                const addressIndex = parts.findIndex((part, idx) => /^0x[a-fA-F0-9]{40}$/.test(part) && !usedIndices.has(idx));
                if (addressIndex !== -1) {
                    values.params[param] = parts[addressIndex];
                    usedIndices.add(addressIndex);
                    valueFound = true;
                }
            }
            else if (possibleValues.length > 0) {
                const index = parts.findIndex((part, idx) => possibleValues.includes(part.toLowerCase()) &&
                    !usedIndices.has(idx));
                if (index !== -1) {
                    values.params[param] = parts[index];
                    usedIndices.add(index);
                    valueFound = true;
                }
            }
            else {
                const indices = parts.reduce((acc, part, idx) => {
                    if (!usedIndices.has(idx) &&
                        (type === "number"
                            ? !isNaN(parseFloat(part))
                            : type === "username"
                                ? part.startsWith("@")
                                : true)) {
                        acc.push(idx);
                    }
                    return acc;
                }, []);
                if (indices.length > 0) {
                    if (type === "username") {
                        const usernames = indices.map((idx) => parts[idx].slice(1));
                        const mappedUsers = mapUsernamesToInboxId(usernames, members);
                        //@ts-ignore
                        values.params[param] = mappedUsers.filter((user) => user !== undefined);
                        indices.forEach((idx) => usedIndices.add(idx));
                    }
                    else {
                        values.params[param] =
                            type === "number"
                                ? parseFloat(parts[indices[0]])
                                : parts[indices[0]];
                        usedIndices.add(indices[0]);
                    }
                    valueFound = true;
                }
            }
            if (!valueFound && defaultValue !== undefined) {
                //@ts-ignore
                values.params[param] = defaultValue;
            }
        });
        return values;
    }
    catch (e) {
        console.error(e);
        return defaultResult;
    }
}

class HandlerContext {
    refConv = null;
    message;
    group;
    conversation;
    client;
    version;
    v2client;
    commands;
    isGroup;
    members;
    getMessageById;
    constructor(conversation, { client, v2client }, version) {
        this.client = client;
        this.v2client = v2client;
        this.isGroup = version === "v3";
        if (conversation instanceof nodeSdk.Conversation) {
            this.group = {
                id: conversation.id,
                sync: conversation.sync.bind(conversation),
                addMembers: conversation.addMembers.bind(conversation),
                send: conversation.send.bind(conversation),
                createdAt: conversation.createdAt,
                addMembersByInboxId: conversation.addMembersByInboxId.bind(conversation),
            };
            this.version = "v3";
        }
        else {
            this.conversation = conversation;
            this.version = "v2";
        }
    }
    static async loadCommandConfig(configPath = "commands.js") {
        const resolvedPath = path.resolve(process.cwd(), "dist/" + configPath);
        try {
            const module = await import(resolvedPath);
            const commandConfig = module.commands; // Access the exported variable
            return commandConfig;
        }
        catch (error) {
            //console.error(`No commands.ts file found`);
            return [];
        }
    }
    static async create(conversation, message, { client, v2client }, commandsConfigPath, version) {
        const context = new HandlerContext(conversation, { client, v2client }, version);
        if (message) {
            //v2
            const senderAddress = "senderAddress" in message
                ? message.senderAddress
                : message.senderInboxId;
            const sentAt = "sentAt" in message ? message.sentAt : message.sent;
            context.members = await populateUsernames("members" in conversation
                ? (await conversation.members()).map((member) => ({
                    inboxId: member.inboxId,
                    username: "",
                    address: member.accountAddresses[0] || "",
                    accountAddresses: member.accountAddresses,
                }))
                : [], client.accountAddress, senderAddress);
            //commands
            context.commands =
                await HandlerContext.loadCommandConfig(commandsConfigPath);
            context.getMessageById =
                client.conversations?.getMessageById?.bind(client.conversations) ||
                    (() => null);
            // **Correct Binding:**
            context.getReplyChain = context.getReplyChain.bind(context);
            //trim spaces from text
            let content = typeof message.content === "string"
                ? message.content.trim()
                : message.content;
            if (message.contentType.sameAs(contentTypeText.ContentTypeText)) {
                content = parseCommand(content, context.commands ?? [], context.members ?? []);
            }
            else if (message.contentType.sameAs(contentTypeReply.ContentTypeReply)) {
                content = {
                    ...content,
                    typeId: message.content.contentType.typeId,
                };
            }
            else if (message.contentType.sameAs(contentTypeRemoteAttachment.ContentTypeRemoteAttachment)) {
                const attachment = await contentTypeRemoteAttachment.RemoteAttachmentCodec.load(content, client);
                content = {
                    ...content,
                    attachment: attachment,
                };
            }
            //v2
            const sender = context.members?.find((member) => member.inboxId === senderAddress) ||
                { address: senderAddress, inboxId: senderAddress };
            context.message = {
                id: message.id,
                content: content,
                sender: sender,
                typeId: message.contentType.typeId,
                sent: sentAt,
                version: version,
            };
        }
        else {
            context.message = {
                id: "",
                content: "",
                sender: {
                    inboxId: "",
                    address: "",
                    username: "",
                    accountAddresses: [],
                },
                typeId: "new_" + (context.isGroup ? "group" : "conversation"),
                sent: conversation.createdAt,
                version: version,
            };
        }
        return context;
    }
    async getV2MessageById(reference) {
        const conversations = await this.v2client.conversations.list();
        for (const conversation of conversations) {
            const messages = await conversation.messages();
            if (messages.find((m) => m.id === reference)) {
                return messages.find((m) => m.id === reference);
            }
        }
        return null;
    }
    async getReplyChain(reference, version, botAddress) {
        let msg = null;
        let senderAddress = "";
        if (version === "v3")
            msg = await this.getMessageById(reference);
        else if (version === "v2")
            msg = await this.getV2MessageById(reference);
        if (!msg) {
            return {
                chain: [],
                isSenderInChain: false,
            };
        }
        let sender = this.members?.find((member) => member.inboxId === msg.senderInboxId ||
            member.address === msg.senderAddress);
        senderAddress = sender?.address ?? "";
        let content = msg?.content?.content ?? msg?.content;
        let isSenderBot = senderAddress.toLowerCase() === botAddress?.toLowerCase();
        let chain = [{ address: senderAddress, content: content }];
        if (msg?.content?.reference) {
            const { chain: replyChain, isSenderInChain } = await this.getReplyChain(msg.content.reference, version, botAddress);
            chain = replyChain;
            isSenderBot = isSenderBot || isSenderInChain;
            chain.push({
                address: senderAddress,
                content: content,
            });
        }
        return {
            chain: chain,
            isSenderInChain: isSenderBot,
        };
    }
    async reply(message) {
        const reply = {
            content: message,
            contentType: contentTypeText.ContentTypeText,
            reference: this.message.id,
        };
        const conversation = this.refConv || this.conversation || this.group;
        /*console.log(
          this.version,
          this.isConversationV2(conversation),
          this.refConv,
          this.conversation,
          this.group,
        );*/
        if (conversation) {
            if (this.isConversationV2(conversation)) {
                await conversation.send(reply, { contentType: contentTypeReply.ContentTypeReply });
            }
            else {
                await conversation.send(reply, contentTypeReply.ContentTypeReply);
            }
        }
    }
    async send(message) {
        const conversation = this.refConv || this.conversation || this.group;
        if (conversation)
            await conversation.send(message);
    }
    isConversationV2(conversation) {
        return conversation?.topic !== undefined;
    }
    async react(emoji) {
        const reaction = {
            action: "added",
            schema: "unicode",
            reference: this.message.id,
            content: emoji,
        };
        const conversation = this.refConv || this.conversation || this.group;
        if (conversation) {
            if (this.isConversationV2(conversation)) {
                await conversation.send(reaction, { contentType: contentTypeReaction.ContentTypeReaction });
            }
            else if (conversation instanceof nodeSdk.Conversation) {
                await conversation.send(reaction, contentTypeReaction.ContentTypeReaction);
            }
        }
    }
    async getCacheCreationDate() {
        //Gets the creation date of the cache folder
        //Could be used to check if the cache is outdated
        //Generally indicates the deployment date of the bot
        try {
            const stats = await fs.stat(".cache");
            const cacheCreationDate = new Date(stats.birthtime);
            return cacheCreationDate;
        }
        catch (err) {
            console.error(err);
        }
    }
    async sendTo(message, receivers) {
        const conversations = await this.v2client.conversations.list();
        //Sends a 1 to 1 to multiple users
        for (const receiver of receivers) {
            if (this.v2client.address.toLowerCase() === receiver.toLowerCase()) {
                continue;
            }
            let targetConversation = conversations.find((conv) => conv.peerAddress.toLowerCase() === receiver.toLowerCase());
            if (!targetConversation) {
                targetConversation =
                    await this.v2client.conversations.newConversation(receiver);
            }
            // Send the message only once per receiver
            await targetConversation.send(message);
        }
    }
    async intent(text, conversation) {
        const { commands, members } = this;
        if (conversation)
            this.refConv = conversation;
        try {
            const handler = this.commands?.find((command) => command.triggers?.includes(text.split(" ")[0]));
            if (handler) {
                let content = parseCommand(text, commands ?? [], members ?? []);
                // Mock context for command execution
                const mockContext = {
                    ...this,
                    conversation: conversation ?? this.conversation,
                    message: {
                        ...this.message,
                        content,
                    },
                    intent: this.intent.bind(this),
                    reply: this.reply.bind(this),
                    send: this.send.bind(this),
                    sendTo: this.sendTo.bind(this),
                    react: this.react.bind(this),
                    getMessageById: this.getMessageById.bind(this),
                    getReplyChain: this.getReplyChain.bind(this),
                    isGroup: this.group instanceof nodeSdk.Conversation,
                };
                this.refConv = null;
                return await handler?.commands[0].handler?.(mockContext);
            }
            else
                this.send(text);
        }
        catch (e) {
            console.log("error", e);
        }
        finally {
            this.refConv = null;
        }
    }
}

async function xmtpClient(clientConfig = {}, privateKey = null, logging = "off") {
    // Check if both clientConfig and privateKey are empty
    let key = privateKey ?? process.env.KEY;
    if (!viem.isHex(key)) {
        key = accounts.generatePrivateKey();
        console.error(".env KEY not set. Using random one:\n", key);
    }
    const account = accounts.privateKeyToAccount(key);
    const wallet = viem.createWalletClient({
        account,
        chain: chains.mainnet,
        transport: viem.http(),
    });
    let env = process.env.XMTP_ENV;
    if (!env) {
        env = "production";
    }
    if (!fs__namespace.existsSync(`.data`)) {
        fs__namespace.mkdirSync(`.data`);
    }
    const defaultConfig = {
        env: env,
        dbPath: `.data/${wallet.account?.address}-${env}`,
        logging: logging,
        codecs: [
            new contentTypeText.TextCodec(),
            new contentTypeReaction.ReactionCodec(),
            new contentTypeReply.ReplyCodec(),
            new contentTypeRemoteAttachment.RemoteAttachmentCodec(),
            new contentTypeRemoteAttachment.AttachmentCodec(),
        ],
    };
    // Merge the default configuration with the provided config. Repeated fields in clientConfig will override the default values
    const finalConfig = { ...defaultConfig, ...clientConfig };
    const client = await nodeSdk.Client.create(account.address, finalConfig);
    //v2
    const wallet2 = new ethers.Wallet(key);
    const v2client = await xmtpJs.Client.create(wallet2, {
        ...finalConfig,
        apiUrl: undefined,
        skipContactPublishing: false,
        apiClientFactory: grpcApiClient.GrpcApiClient.fromOptions,
    });
    console.log("Listening on client: ", {
        accountAddress: client.accountAddress,
        inboxId: client.inboxId,
        installationId: client.installationId,
    });
    // register identity
    if (!client.isRegistered && client.signatureText) {
        const signatureText = await client.signatureText();
        if (signatureText) {
            const signature = await wallet.signMessage({
                message: signatureText,
            });
            const signatureBytes = viem.toBytes(signature);
            if (signatureBytes) {
                client.addSignature(signatureBytes);
            }
        }
        await client.registerIdentity();
    }
    //commands
    // check if file exists
    const resolvedPath = path__namespace.resolve(process.cwd(), "src/" + "commands.ts");
    if (!fs__namespace.existsSync(resolvedPath)) {
        console.error(`No commands.ts file found`);
    }
    return { client, v2client };
}

async function run(handler, config) {
    const { client, v2client } = await xmtpClient(config?.client, config?.privateKey, config?.logging);
    const { inboxId: address } = client;
    const { address: addressV2 } = v2client;
    // sync and list conversations
    await client.conversations.sync();
    await client.conversations.list();
    const handleMessage = async (version, message, conversation) => {
        if (message && conversation) {
            try {
                const { senderInboxId, kind } = message;
                const senderAddress = message.senderAddress;
                if (
                //If same address do nothin
                senderAddress?.toLowerCase() === addressV2?.toLowerCase() ||
                    //If same address do nothin
                    // Filter out membership_change messages
                    (senderInboxId?.toLowerCase() === address?.toLowerCase() &&
                        kind !== "membership_change")) {
                    return;
                }
                const context = await HandlerContext.create(conversation, message, { client, v2client }, config?.commandsConfigPath, version);
                // Check if the message content triggers a command
                if (!commandTriggered(version, context, message))
                    return;
                await handler(context);
            }
            catch (e) {
                console.log(`error`, e);
            }
        }
    };
    const commandTriggered = (version, context, message) => {
        if (process.env.MSG_LOG) ;
        const typeId = message?.contentType?.typeId;
        const isAddedMember = typeId == "group_updated" && message?.content?.addedInboxes?.length > 0;
        const isRemoteAttachment = message?.contentType?.typeId == "remoteStaticAttachment";
        // Remote attachments work if image:true
        // Replies only work with explicit mentions from triggers.
        // Text only works with explicit mentions from triggers.
        // Reactions dont work with triggers.
        const commandTriggered = isAddedMember
            ? true
            : version == "v2" &&
                (typeId === "text" ||
                    typeId === "remoteStaticAttachment" ||
                    typeId === "reply")
                ? true
                : context.commands?.some((commandGroup) => isRemoteAttachment && commandGroup.image
                    ? true
                    : commandGroup.triggers.some((trigger) => {
                        switch (typeId) {
                            case "text":
                                return message?.content
                                    ?.toLowerCase()
                                    .includes(trigger?.toLowerCase());
                            case "reply":
                                return message?.content?.content
                                    ?.toLowerCase()
                                    .includes(trigger?.toLowerCase());
                            default:
                                return false;
                        }
                    }));
        if (commandTriggered) {
            console.log(`msg_${version}:`, typeof message?.content === "string"
                ? message?.content.substring(0, 20) +
                    (message?.content.length > 20 ? "..." : "")
                : message?.contentType?.typeId ??
                    message?.content?.contentType?.typeId);
        }
        return commandTriggered;
    };
    const streamMessages = async (version) => {
        if (version === "v3") {
            while (true) {
                const stream = await client.conversations.streamAllMessages();
                try {
                    for await (const message of stream) {
                        const conversation = await client.conversations.getConversationById(message?.conversationId ?? "");
                        handleMessage(version, message, conversation);
                    }
                }
                catch (e) {
                    console.log(`Restart stream:`, e);
                }
            }
        }
        else if (version === "v2") {
            while (true) {
                const stream = await v2client.conversations.streamAllMessages();
                try {
                    for await (const message of stream) {
                        handleMessage(version, message, message.conversation);
                    }
                }
                catch (e) {
                    console.log(`Restart stream:`, e);
                }
            }
        }
    };
    // Run both clients' streams concurrently
    await Promise.all([streamMessages("v2"), streamMessages("v3")]);
}

exports.HandlerContext = HandlerContext;
exports.run = run;
exports.xmtpClient = xmtpClient;
//# sourceMappingURL=index.cjs.map
