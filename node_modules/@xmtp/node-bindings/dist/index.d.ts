/* auto-generated by NAPI-RS */
/* eslint-disable */
export class NapiClient {
  accountAddress: string
  inboxId(): string
  isRegistered(): boolean
  installationId(): string
  canMessage(accountAddresses: Array<string>): Promise<Record<string, boolean>>
  registerIdentity(): Promise<void>
  createInboxSignatureText(): Promise<string | null>
  conversations(): NapiConversations
  requestHistorySync(): Promise<void>
  findInboxIdByAddress(address: string): Promise<string | null>
  /**
   * Get the client's inbox state.
   *
   * If `refresh_from_network` is true, the client will go to the network first to refresh the state.
   * Otherwise, the state will be read from the local database.
   */
  inboxState(refreshFromNetwork: boolean): Promise<NapiInboxState>
  addressesFromInboxId(refreshFromNetwork: boolean, inboxIds: Array<string>): Promise<Array<NapiInboxState>>
  getLatestInboxState(inboxId: string): Promise<NapiInboxState>
  addWalletSignatureText(existingWalletAddress: string, newWalletAddress: string): Promise<string>
  revokeWalletSignatureText(walletAddress: string): Promise<string>
  revokeInstallationsSignatureText(): Promise<string>
  addSignature(signatureType: NapiSignatureRequestType, signatureBytes: Uint8Array): Promise<void>
  applySignatureRequests(): Promise<void>
  setConsentStates(records: Array<NapiConsent>): Promise<void>
  getConsentState(entityType: NapiConsentEntityType, entity: string): Promise<NapiConsentState>
}

export class NapiConversations {
  createGroup(accountAddresses: Array<string>, options?: NapiCreateGroupOptions | undefined | null): Promise<NapiGroup>
  findGroupById(groupId: string): NapiGroup
  findMessageById(messageId: string): NapiMessage
  processStreamedWelcomeMessage(envelopeBytes: Uint8Array): Promise<NapiGroup>
  sync(): Promise<void>
  list(opts?: NapiListConversationsOptions | undefined | null): Promise<Array<NapiGroup>>
  stream(callback: (err: null | Error, result: NapiGroup) => void): NapiStreamCloser
  streamAllMessages(callback: (err: null | Error, result: NapiMessage) => void): NapiStreamCloser
}

export class NapiGroup {
  id(): string
  send(encodedContent: NapiEncodedContent): Promise<string>
  /** send a message without immediately publishing to the delivery service. */
  sendOptimistic(encodedContent: NapiEncodedContent): string
  /** Publish all unpublished messages */
  publishMessages(): Promise<void>
  sync(): Promise<void>
  findMessages(opts?: NapiListMessagesOptions | undefined | null): Array<NapiMessage>
  processStreamedGroupMessage(envelopeBytes: Uint8Array): Promise<NapiMessage>
  listMembers(): Promise<Array<NapiGroupMember>>
  adminList(): Array<string>
  superAdminList(): Array<string>
  isAdmin(inboxId: string): boolean
  isSuperAdmin(inboxId: string): boolean
  addMembers(accountAddresses: Array<string>): Promise<void>
  addAdmin(inboxId: string): Promise<void>
  removeAdmin(inboxId: string): Promise<void>
  addSuperAdmin(inboxId: string): Promise<void>
  removeSuperAdmin(inboxId: string): Promise<void>
  groupPermissions(): NapiGroupPermissions
  addMembersByInboxId(inboxIds: Array<string>): Promise<void>
  removeMembers(accountAddresses: Array<string>): Promise<void>
  removeMembersByInboxId(inboxIds: Array<string>): Promise<void>
  updateGroupName(groupName: string): Promise<void>
  groupName(): string
  updateGroupImageUrlSquare(groupImageUrlSquare: string): Promise<void>
  groupImageUrlSquare(): string
  updateGroupDescription(groupDescription: string): Promise<void>
  groupDescription(): string
  updateGroupPinnedFrameUrl(pinnedFrameUrl: string): Promise<void>
  groupPinnedFrameUrl(): string
  stream(callback: (err: null | Error, result: NapiMessage) => void): NapiStreamCloser
  createdAtNs(): number
  isActive(): boolean
  addedByInboxId(): string
  groupMetadata(): NapiGroupMetadata
  consentState(): NapiConsentState
  updateConsentState(state: NapiConsentState): void
}

export class NapiGroupMember {
  inboxId: string
  accountAddresses: Array<string>
  installationIds: Array<string>
  permissionLevel: NapiPermissionLevel
  consentState: NapiConsentState
}

export class NapiGroupMetadata {
  creatorInboxId(): string
  conversationType(): string
}

export class NapiGroupPermissions {
  policyType(): NapiGroupPermissionsOptions
  policySet(): NapiPermissionPolicySet
}

export class NapiMessage {
  id: string
  sentAtNs: number
  convoId: string
  senderInboxId: string
  content: NapiEncodedContent
  kind: NapiGroupMessageKind
  deliveryStatus: NapiDeliveryStatus
}

export class NapiStreamCloser {
  /**
   * Signal the stream to end
   * Does not wait for the stream to end.
   */
  end(): void
  /**
   * End the stream and `await` for it to shutdown
   * Returns the `Result` of the task.
   * End the stream and asyncronously wait for it to shutdown
   */
  endAndWait(): Promise<void>
  /** Checks if this stream is closed */
  isClosed(): boolean
}

/**
 * Create an MLS client
 * Optionally specify a filter for the log level as a string.
 * It can be one of: `debug`, `info`, `warn`, `error` or 'off'.
 * By default, logging is set to `info`. `off` completely disables logging.
 */
export function createClient(host: string, isSecure: boolean, dbPath: string, inboxId: string, accountAddress: string, encryptionKey?: Uint8Array | undefined | null, historySyncUrl?: string | undefined | null, envFilter?: string | undefined | null): Promise<NapiClient>

export function generateInboxId(accountAddress: string): string

export function getInboxIdForAddress(host: string, isSecure: boolean, accountAddress: string): Promise<string | null>

export interface NapiConsent {
  entityType: NapiConsentEntityType
  state: NapiConsentState
  entity: string
}

export const enum NapiConsentEntityType {
  GroupId = 0,
  InboxId = 1,
  Address = 2
}

export const enum NapiConsentState {
  Unknown = 0,
  Allowed = 1,
  Denied = 2
}

export interface NapiContentTypeId {
  authorityId: string
  typeId: string
  versionMajor: number
  versionMinor: number
}

export interface NapiCreateGroupOptions {
  permissions?: NapiGroupPermissionsOptions
  groupName?: string
  groupImageUrlSquare?: string
  groupDescription?: string
  groupPinnedFrameUrl?: string
}

export const enum NapiDeliveryStatus {
  Unpublished = 0,
  Published = 1,
  Failed = 2
}

export interface NapiEncodedContent {
  type?: NapiContentTypeId
  parameters: Record<string, string>
  fallback?: string
  compression?: number
  content: Uint8Array
}

export const enum NapiGroupMessageKind {
  Application = 0,
  MembershipChange = 1
}

export const enum NapiGroupPermissionsOptions {
  AllMembers = 0,
  AdminOnly = 1,
  CustomPolicy = 2
}

export interface NapiInboxState {
  inboxId: string
  recoveryAddress: string
  installations: Array<NapiInstallation>
  accountAddresses: Array<string>
}

export interface NapiInstallation {
  id: string
  clientTimestampNs?: bigint
}

export interface NapiListConversationsOptions {
  createdAfterNs?: number
  createdBeforeNs?: number
  limit?: number
}

export interface NapiListMessagesOptions {
  sentBeforeNs?: number
  sentAfterNs?: number
  limit?: number
  deliveryStatus?: NapiDeliveryStatus
}

export const enum NapiPermissionLevel {
  Member = 0,
  Admin = 1,
  SuperAdmin = 2
}

export const enum NapiPermissionPolicy {
  Allow = 0,
  Deny = 1,
  Admin = 2,
  SuperAdmin = 3,
  DoesNotExist = 4,
  Other = 5
}

export interface NapiPermissionPolicySet {
  addMemberPolicy: NapiPermissionPolicy
  removeMemberPolicy: NapiPermissionPolicy
  addAdminPolicy: NapiPermissionPolicy
  removeAdminPolicy: NapiPermissionPolicy
  updateGroupNamePolicy: NapiPermissionPolicy
  updateGroupDescriptionPolicy: NapiPermissionPolicy
  updateGroupImageUrlSquarePolicy: NapiPermissionPolicy
  updateGroupPinnedFrameUrlPolicy: NapiPermissionPolicy
}

export const enum NapiPermissionUpdateType {
  AddMember = 0,
  RemoveMember = 1,
  AddAdmin = 2,
  RemoveAdmin = 3,
  UpdateMetadata = 4
}

export const enum NapiSignatureRequestType {
  AddWallet = 0,
  CreateInbox = 1,
  RevokeWallet = 2,
  RevokeInstallations = 3
}

