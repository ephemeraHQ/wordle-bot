import{ciphertext as e,privateKey as t,signature as s,publicKey as n,fetcher as r,keystore as i,message as o,content as a,authn as c,messageApi as d,invitation as h,contact as y,privatePreferences as u,composite as p}from"@xmtp/proto";import l from"long";import*as w from"@noble/secp256k1";import{bytesToHex as f,keccak256 as m,getAddress as g,hexToSignature as v,hexToBytes as b,hashMessage as E,verifyMessage as K}from"viem";import{Mutex as A}from"async-mutex";import T from"elliptic";import k,{user_preferences_encrypt as S,user_preferences_decrypt as P,generate_private_preferences_topic as C}from"@xmtp/user-preferences-bindings-wasm/web";import{createConsentMessage as B}from"@xmtp/consent-proof-signature";class I{constructor(e){if(!e.aes256GcmHkdfSha256)throw new Error("invalid ciphertext");if(e.aes256GcmHkdfSha256.payload.length<16)throw new Error(`invalid ciphertext ciphertext length: ${e.aes256GcmHkdfSha256.payload.length}`);if(32!==e.aes256GcmHkdfSha256.hkdfSalt.length)throw new Error(`invalid ciphertext salt length: ${e.aes256GcmHkdfSha256.hkdfSalt.length}`);if(12!==e.aes256GcmHkdfSha256.gcmNonce.length)throw new Error(`invalid ciphertext nonce length: ${e.aes256GcmHkdfSha256.gcmNonce.length}`);this.aes256GcmHkdfSha256=e.aes256GcmHkdfSha256}toBytes(){return e.Ciphertext.encode(this).finish()}static fromBytes(t){return new I(e.Ciphertext.decode(t))}}const R=window.crypto,N=(new Uint8Array).buffer,D=(new Uint8Array).buffer;async function M(e){return new Uint8Array(await R.subtle.digest("SHA-256",e))}async function _(e,t,s){const n=R.getRandomValues(new Uint8Array(32)),r=R.getRandomValues(new Uint8Array(12)),i=await U(t,n),o=await R.subtle.encrypt(V(r,s),i,e);return new I({aes256GcmHkdfSha256:{payload:new Uint8Array(o),hkdfSalt:n,gcmNonce:r}})}async function x(e,t,s){if(!e.aes256GcmHkdfSha256)throw new Error("invalid payload ciphertext");const n=await U(t,e.aes256GcmHkdfSha256.hkdfSalt),r=await R.subtle.decrypt(V(e.aes256GcmHkdfSha256.gcmNonce,s),n,e.aes256GcmHkdfSha256.payload);return new Uint8Array(r)}function V(e,t){const s={name:"AES-GCM",iv:e};return t&&(s.additionalData=t),s}async function U(e,t){const s=await R.subtle.importKey("raw",e,"HKDF",!1,["deriveKey"]);return R.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:t,info:N},s,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}async function q(e,t){const s=await R.subtle.importKey("raw",e,"HKDF",!1,["deriveKey"]);return R.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:D,info:t},s,{name:"HMAC",hash:"SHA-256",length:256},!0,["sign","verify"])}async function O(e,t,s){const n=await q(e,t),r=await R.subtle.sign("HMAC",n,s);return new Uint8Array(r)}async function L(e,t,s){return await R.subtle.verify("HMAC",e,t,s)}async function H(e){const t=await R.subtle.exportKey("raw",e);return new Uint8Array(t)}async function F(e){return R.subtle.importKey("raw",e,{name:"HMAC",hash:"SHA-256",length:256},!0,["sign","verify"])}const G=w.utils.bytesToHex;function $(e,t){if(e.length!==t.length)return!1;for(let s=0;s<e.length;s++)if(e[s]!==t[s])return!1;return!0}function j(e){const t=v(e),s=b(t.r),n=b(t.s);let r=Number(t.v);0!==r&&1!==r||(r+=27);const i=1-r%2,o=new Uint8Array(64);return o.set(s),o.set(n,s.length),{bytes:o,recovery:i}}function X(e){if(32!==e.bytes.length)throw new Error(`invalid private key length: ${e.bytes.length}`)}class J{constructor(e){if(!e.secp256k1)throw new Error("invalid private key");if(X(e.secp256k1),this.secp256k1=e.secp256k1,this.createdNs=e.createdNs,!e.publicKey)throw new Error("missing public key");this.publicKey=new re(e.publicKey)}static async generate(e){const t={bytes:w.utils.randomPrivateKey()},s=l.fromNumber((new Date).getTime()).mul(1e6),n=new ne({secp256k1Uncompressed:{bytes:w.getPublicKey(t.bytes)},createdNs:s}),r=await e.signKey(n);return new J({secp256k1:t,createdNs:s,publicKey:r})}generated(){return new Date(this.createdNs.div(1e6).toNumber())}async sign(e){const[t,s]=await w.sign(e,this.secp256k1.bytes,{recovered:!0,der:!1});return new Z({ecdsaCompact:{bytes:t,recovery:s}})}async signKey(e){const t=e.toBytes(),s=await M(t),n=await this.sign(s);return new re({keyBytes:t,signature:n})}static async signerKey(e,t){return Q(await M(e.bytesToSign()),t)}sharedSecret(e){return w.getSharedSecret(this.secp256k1.bytes,e.secp256k1Uncompressed.bytes,!1)}encrypt(e,t,s){return _(e,this.sharedSecret(t),s)}decrypt(e,t,s){return x(e,this.sharedSecret(t),s)}matches(e){return this.publicKey.equals(e)}equals(e){return $(this.secp256k1.bytes,e.secp256k1.bytes)&&this.publicKey.equals(e.publicKey)}toBytes(){return t.SignedPrivateKey.encode(this).finish()}validatePublicKey(){return $(w.getPublicKey(this.secp256k1.bytes),this.publicKey.secp256k1Uncompressed.bytes)}static fromBytes(e){return new J(t.SignedPrivateKey.decode(e))}static fromLegacyKey(e,t){return new J({createdNs:e.timestamp.mul(1e6),secp256k1:e.secp256k1,publicKey:re.fromLegacyKey(e.publicKey,t)})}}class z{constructor(e){if(!e.secp256k1)throw new Error("invalid private key");if(X(e.secp256k1),this.timestamp=e.timestamp,this.secp256k1=e.secp256k1,!e.publicKey)throw new Error("missing public key");this.publicKey=new ie(e.publicKey)}static generate(){const e={bytes:w.utils.randomPrivateKey()},t=l.fromNumber((new Date).getTime());return new z({secp256k1:e,timestamp:t,publicKey:new ie({secp256k1Uncompressed:{bytes:w.getPublicKey(e.bytes)},timestamp:t})})}generated(){return new Date(this.timestamp.toNumber())}async sign(e){const[t,s]=await w.sign(e,this.secp256k1.bytes,{recovered:!0,der:!1});return new Z({ecdsaCompact:{bytes:t,recovery:s}})}async signKey(e){const t=await M(e.bytesToSign());return e.signature=await this.sign(t),e}sharedSecret(e){return w.getSharedSecret(this.secp256k1.bytes,e.secp256k1Uncompressed.bytes,!1)}encrypt(e,t,s){return _(e,this.sharedSecret(t),s)}decrypt(e,t,s){return x(e,this.sharedSecret(t),s)}matches(e){return this.publicKey.equals(e)}validatePublicKey(){return $(w.getPublicKey(this.secp256k1.bytes),this.publicKey.secp256k1Uncompressed.bytes)}toBytes(){return t.PrivateKey.encode(this).finish()}static fromBytes(e){return new z(t.PrivateKey.decode(e))}}function Y(e){if(64!==e.bytes.length)throw new Error(`invalid signature length: ${e.bytes.length}`);if(0!==e.recovery&&1!==e.recovery)throw new Error(`invalid recovery bit: ${e.recovery}`)}function W(e,t){return e.recovery===t.recovery&&$(e.bytes,t.bytes)}function Q(e,t){const s=w.recoverPublicKey(e,t.bytes,t.recovery);return s?new ne({secp256k1Uncompressed:{bytes:s},createdNs:l.fromNumber(0)}):void 0}class Z{constructor(e){if(e.ecdsaCompact)Y(e.ecdsaCompact),this.ecdsaCompact=e.ecdsaCompact;else{if(!e.walletEcdsaCompact)throw new Error("invalid signature");Y(e.walletEcdsaCompact),this.walletEcdsaCompact=e.walletEcdsaCompact}}async signerKey(e){return this.ecdsaCompact?J.signerKey(e,this.ecdsaCompact):this.walletEcdsaCompact?te.signerKey(e,this.walletEcdsaCompact):void 0}getPublicKey(e){let t;if(this.ecdsaCompact)t=w.recoverPublicKey(e,this.ecdsaCompact.bytes,this.ecdsaCompact.recovery);else{if(!this.walletEcdsaCompact)throw new Error("invalid v1 signature");t=w.recoverPublicKey(e,this.walletEcdsaCompact.bytes,this.walletEcdsaCompact.recovery)}return t?new ie({secp256k1Uncompressed:{bytes:t},timestamp:l.fromNumber(0)}):void 0}equals(e){return this.ecdsaCompact&&e.ecdsaCompact?W(this.ecdsaCompact,e.ecdsaCompact):!(!this.walletEcdsaCompact||!e.walletEcdsaCompact)&&W(this.walletEcdsaCompact,e.walletEcdsaCompact)}toBytes(){return s.Signature.encode(this).finish()}static fromBytes(e){return new Z(s.Signature.decode(e))}}var ee;!function(e){e[e.INBOX_KEY=0]="INBOX_KEY",e[e.SEND_KEY=1]="SEND_KEY"}(ee||(ee={}));class te{constructor(e){this.wallet=e}static identitySigRequestText(e){return`XMTP : Create Identity\n${G(e)}\n\nFor more info: https://xmtp.org/signatures/`}static signerKey(e,t){return Q(b(E(this.identitySigRequestText(e.bytesToSign()))),t)}async signKey(e){const t=e.toBytes(),s=await this.wallet.signMessage(te.identitySigRequestText(t)),{bytes:n,recovery:r}=j(s),i=new Z({walletEcdsaCompact:{bytes:n,recovery:r}});return new re({keyBytes:t,signature:i})}}const se=new l(10**9).mul(10**9);class ne{constructor(e){if(!e?.secp256k1Uncompressed)throw new Error("invalid public key");!function(e){if(65!==e.bytes.length)throw new Error(`invalid public key length: ${e.bytes.length}`);if(4!==e.bytes[0])throw new Error(`unrecognized public key prefix: ${e.bytes[0]}`)}(e.secp256k1Uncompressed),this.secp256k1Uncompressed=e.secp256k1Uncompressed,this.createdNs=e.createdNs.toUnsigned()}generated(){return new Date(this.timestamp.toNumber())}isFromLegacyKey(){return this.createdNs.lessThan(se)}get timestamp(){return(this.isFromLegacyKey()?this.createdNs:this.createdNs.div(1e6)).toUnsigned()}verify(e,t){return!!e.ecdsaCompact&&w.verify(e.ecdsaCompact.bytes,t,this.secp256k1Uncompressed.bytes)}async verifyKey(e){if(!e.signature)return!1;const t=await M(e.bytesToSign());return this.verify(e.signature,t)}equals(e){return $(this.secp256k1Uncompressed.bytes,e.secp256k1Uncompressed.bytes)}getEthereumAddress(){return function(e){const t=f(e.slice(1)),s=m(t),n=s.substring(s.length-40);return g(`0x${n}`)}(this.secp256k1Uncompressed.bytes)}toBytes(){return n.UnsignedPublicKey.encode(this).finish()}static fromBytes(e){return new ne(n.UnsignedPublicKey.decode(e))}}class re extends ne{constructor(e){if(!e.keyBytes)throw new Error("missing key bytes");if(super(n.UnsignedPublicKey.decode(e.keyBytes)),this.keyBytes=e.keyBytes,!e.signature)throw new Error("missing key signature");this.signature=new Z(e.signature)}get unsignedKey(){return new ne({createdNs:this.createdNs,secp256k1Uncompressed:this.secp256k1Uncompressed})}signerKey(){return this.signature.signerKey(this)}async walletSignatureAddress(){if(!this.signature.walletEcdsaCompact)throw new Error("key was not signed by a wallet");const e=await this.signerKey();if(!e)throw new Error("key signature not valid");return e.getEthereumAddress()}equals(e){return this.unsignedKey.equals(e.unsignedKey)&&this.signature.equals(e.signature)}bytesToSign(){return this.keyBytes}toBytes(){return n.SignedPublicKey.encode(this).finish()}static fromBytes(e){return new re(n.SignedPublicKey.decode(e))}toLegacyKey(){if(!this.isFromLegacyKey())throw new Error("cannot be converted to legacy key");let e=this.signature;return e.walletEcdsaCompact&&(e=new Z({ecdsaCompact:e.walletEcdsaCompact})),new ie({timestamp:this.timestamp,secp256k1Uncompressed:this.secp256k1Uncompressed,signature:e})}static fromLegacyKey(e,t){if(!e.signature)throw new Error("key is not signed");let s=e.signature;return t&&(s=new Z({walletEcdsaCompact:s.ecdsaCompact})),new re({keyBytes:e.bytesToSign(),signature:s})}}class ie extends ne{constructor(e){super({createdNs:e.timestamp.mul(1e6),secp256k1Uncompressed:e.secp256k1Uncompressed}),e.signature&&(!e.signature.ecdsaCompact&&e.signature.walletEcdsaCompact?this.signature=new Z({ecdsaCompact:{bytes:e.signature.walletEcdsaCompact.bytes,recovery:e.signature.walletEcdsaCompact.recovery}}):this.signature=new Z(e.signature))}get timestamp(){return this.createdNs.div(1e6)}bytesToSign(){return n.PublicKey.encode({timestamp:this.timestamp,secp256k1Uncompressed:this.secp256k1Uncompressed}).finish()}async signWithWallet(e){const t=await e.signMessage(te.identitySigRequestText(this.bytesToSign())),{bytes:s,recovery:n}=j(t);this.signature=new Z({ecdsaCompact:{bytes:s,recovery:n}})}walletSignatureAddress(){if(!this.signature)throw new Error("key is not signed");const e=b(E(te.identitySigRequestText(this.bytesToSign()))),t=this.signature.getPublicKey(e);if(!t)throw new Error("key signature is malformed");return t.getEthereumAddress()}toBytes(){return n.PublicKey.encode(this).finish()}static fromBytes(e){return new ie(n.PublicKey.decode(e))}}class oe{constructor(e){if(!e.identityKey)throw new Error("missing identity key");if(!e.preKey)throw new Error("missing pre-key");this.identityKey=new re(e.identityKey),this.preKey=new re(e.preKey)}walletSignatureAddress(){return this.identityKey.walletSignatureAddress()}equals(e){return this.identityKey.equals(e.identityKey)&&this.preKey.equals(e.preKey)}toBytes(){return n.SignedPublicKeyBundle.encode(this).finish()}isFromLegacyBundle(){return this.identityKey.isFromLegacyKey()&&this.preKey.isFromLegacyKey()}toLegacyBundle(){return new ae({identityKey:this.identityKey.toLegacyKey(),preKey:this.preKey.toLegacyKey()})}static fromBytes(e){const t=n.SignedPublicKeyBundle.decode(e);return new oe(t)}static fromLegacyBundle(e){return new oe({identityKey:re.fromLegacyKey(e.identityKey,!0),preKey:re.fromLegacyKey(e.preKey)})}}class ae{constructor(e){if(!e.identityKey)throw new Error("missing identity key");if(!e.preKey)throw new Error("missing pre-key");this.identityKey=new ie(e.identityKey),this.preKey=new ie(e.preKey)}equals(e){return this.identityKey.equals(e.identityKey)&&this.preKey.equals(e.preKey)}walletSignatureAddress(){return this.identityKey.walletSignatureAddress()}toBytes(){return n.PublicKeyBundle.encode(this).finish()}static fromBytes(e){const t=n.PublicKeyBundle.decode(e);return new ae(t)}}class ce{constructor(e){this.authorityId=e.authorityId,this.typeId=e.typeId,this.versionMajor=e.versionMajor,this.versionMinor=e.versionMinor}toString(){return`${this.authorityId}/${this.typeId}:${this.versionMajor}.${this.versionMinor}`}static fromString(e){const[t,s]=e.split(":"),[n,r]=t.split("/"),[i,o]=s.split(".");return new ce({authorityId:n,typeId:r,versionMajor:Number(i),versionMinor:Number(o)})}sameAs(e){return this.authorityId===e.authorityId&&this.typeId===e.typeId}}const de=new ce({authorityId:"xmtp.org",typeId:"fallback",versionMajor:1,versionMinor:0}),he=new ce({authorityId:"xmtp.org",typeId:"text",versionMajor:1,versionMinor:0});var ye;!function(e){e.utf8="UTF-8"}(ye||(ye={}));class ue{get contentType(){return he}encode(e){return{type:he,parameters:{encoding:ye.utf8},content:(new TextEncoder).encode(e)}}decode(e){const t=e.parameters.encoding;if(t&&t!==ye.utf8)throw new Error(`unrecognized encoding ${t}`);return(new TextDecoder).decode(e.content)}fallback(e){}shouldPush(){return!0}}class pe{constructor(e,t){this.messageEnvelope=e,this.onSend=t}async messageID(){if(!this.messageEnvelope.message)throw new Error("no envelope message");return G(await M(this.messageEnvelope.message))}async send(){return this.onSend()}}class le{constructor(e,t,s,n,r){this.messages=[],this.resolvers=[],this.topics=t,this.client=e,this.callback=this.newMessageCallback(s,n),this.onConnectionLost=r}newMessageCallback(e,t){return async s=>{if(s.message)try{const n=await e(s);if(!n)return;if(t){const e=t(n);e&&this.resubscribeToTopics(e)}const r=this.resolvers.pop();r?r({value:n}):this.messages.unshift(n)}catch(e){console.warn(e)}}}async start(){if(!this.callback)throw new Error("Missing callback for stream");this.subscriptionManager=this.client.apiClient.subscribe({contentTopics:this.topics},(async e=>{this.callback&&await(this?.callback(e))}),this.onConnectionLost)}static async create(e,t,s,n,r){const i=new le(e,t,s,n,r);return await i.start(),i}[Symbol.asyncIterator](){return this}async return(){return this.subscriptionManager&&await this.subscriptionManager.unsubscribe(),this.callback?(this.callback=void 0,this.resolvers.forEach((e=>e({value:void 0,done:!0}))),{value:void 0,done:!0}):{value:void 0,done:!0}}next(){const e=this.messages.pop();return e?Promise.resolve({value:e}):this.callback?new Promise((e=>this.resolvers.unshift(e))):Promise.resolve({value:void 0,done:!0})}async resubscribeToTopics(e){if(!this.callback||!this.subscriptionManager)throw new Error("Missing callback for stream");if("function"==typeof this.subscriptionManager?.updateContentTopics)return this.subscriptionManager.updateContentTopics(e);await this.subscriptionManager.unsubscribe(),this.topics=e,this.subscriptionManager=this.client.apiClient.subscribe({contentTopics:this.topics},(async e=>{this.callback&&await(this?.callback(e))}),this.onConnectionLost)}}const{b64Decode:we,b64Encode:fe}=r;function me(e,t){const s=new Uint8Array(e.length+t.length);return s.set(e),s.set(t,e.length),s}function ge(e){return l.fromNumber(e.valueOf()).multiply(1e6)}function ve(e){return new Date(e.divide(1e6).toNumber())}const be=e=>e&&ge(e).toString(),Ee=e=>{if(e)return ve(l.fromString(e))};class Ke extends Error{constructor(e,t){super(t),this.code=e}}const Ae=e=>{if(e.error)throw new Ke(e.error.code,e.error.message);if(!e.result)throw new Ke(i.ErrorCode.ERROR_CODE_UNSPECIFIED,"No result from Keystore");if("encrypted"in e.result&&!e.result.encrypted)throw new Error("Missing ciphertext");if("decrypted"in e.result&&!e.result.decrypted)throw new Error("Missing decrypted result");return e.result},Te=(e,t)=>({requests:e.map((e=>{const s=new ae({identityKey:e.header.sender?.identityKey,preKey:e.header.sender?.preKey}),n=t.equals(s);return{payload:e.ciphertext,peerKeys:n?new ae({identityKey:e.header.recipient?.identityKey,preKey:e.header.recipient?.preKey}):s,headerBytes:e.headerBytes,isSender:n}}))}),ke=e=>`/xmtp/0/${e}/proto`,Se=(e,t)=>{const s=[g(e),g(t)];return s.sort(),ke(`dm-${s.join("-")}`)},Pe=e=>ke(`m-${e}`),Ce=e=>ke(`contact-${g(e)}`),Be=e=>ke(`intro-${g(e)}`),Ie=e=>ke(`invite-${g(e)}`),Re=e=>ke(`privatestore-${e}`),Ne=e=>ke(`userpreferences-${e}`),De=e=>{const t=/^[\x21-\x7F]+$/,s=e.indexOf("0/");if(-1!==s){const n=e.substring(s+2,e.lastIndexOf("/proto"));return t.test(n)}return!1};class Me{constructor(e,t,s){this.conversationVersion="v1",this.context=void 0,this.peerAddress=g(t),this.client=e,this.createdAt=s}get clientAddress(){return this.client.address}async allow(){await this.client.contacts.allow([this.peerAddress])}async deny(){await this.client.contacts.deny([this.peerAddress])}get isAllowed(){return this.client.contacts.isAllowed(this.peerAddress)}get isDenied(){return this.client.contacts.isDenied(this.peerAddress)}get consentState(){return this.client.contacts.consentState(this.peerAddress)}get topic(){return Se(this.peerAddress,this.client.address)}get ephemeralTopic(){return Se(this.peerAddress,this.client.address).replace("/xmtp/0/dm-","/xmtp/0/dmE-")}async messages(e){const t=Se(this.peerAddress,this.client.address),s=await this.client.listEnvelopes(t,this.processEnvelope.bind(this),e);return this.decryptBatch(s,t,!1)}messagesPaginated(e){return this.client.listEnvelopesPaginated(this.topic,this.decodeMessage.bind(this),e)}async decodeMessage(e){if(!e.contentTopic)throw new Error("Missing content topic");const t=await this.processEnvelope(e),s=await this.decryptBatch([t],e.contentTopic,!0);if(!s.length)throw new Error("No results");return s[0]}async prepareMessage(e,t){let s,n=await this.client.getUserContact(this.peerAddress);if(!n)throw new Error(`recipient ${this.peerAddress} is not registered`);n instanceof ae||(n=n.toLegacyBundle());const r=t?.ephemeral?this.ephemeralTopic:this.topic;this.client.contacts.addresses.has(this.peerAddress)?s=[r]:(s=[Be(this.peerAddress),Be(this.client.address),r],this.client.contacts.addresses.add(this.peerAddress));const{payload:i}=await this.client.encodeContent(e,t),o=await this.createMessage(i,n,t?.timestamp),a=o.toBytes(),c={contentTopic:r,message:a,timestampNs:be(o.sent)};return new pe(c,(async()=>(await this.client.publishEnvelopes(s.map((e=>({contentTopic:e,message:a,timestamp:o.sent})))),Oe.fromV1Message(o,e,t?.contentType||he,i,r,this))))}streamMessages(e){return le.create(this.client,[this.topic],(async e=>this.decodeMessage(e)),void 0,e)}async processEnvelope({message:e,contentTopic:t}){if(!e||!e.length)throw new Error("empty envelope");const s=await Ue.fromBytes(e),{senderAddress:n,recipientAddress:r}=s;if(!n||!r||!t||Se(n,r)!==this.topic)throw new Error("Headers do not match intended recipient");return s}streamEphemeral(e){return le.create(this.client,[this.ephemeralTopic],this.decodeMessage.bind(this),void 0,e)}async send(e,t){let s,n=await this.client.getUserContact(this.peerAddress);if(!n)throw new Error(`recipient ${this.peerAddress} is not registered`);n instanceof ae||(n=n.toLegacyBundle());const r=t?.ephemeral?this.ephemeralTopic:this.topic;this.client.contacts.addresses.has(this.peerAddress)?s=[r]:(s=[Be(this.peerAddress),Be(this.client.address),r],this.client.contacts.addresses.add(this.peerAddress));const i=t?.contentType||he,{payload:o}=await this.client.encodeContent(e,t),a=await this.createMessage(o,n,t?.timestamp);return await this.client.publishEnvelopes(s.map((e=>({contentTopic:e,message:a.toBytes(),timestamp:a.sent})))),"unknown"===this.consentState&&await this.allow(),Oe.fromV1Message(a,e,i,o,r,this)}async decryptBatch(e,t,s=!1){const n=(await this.client.keystore.decryptV1(Te(e,this.client.publicKeyBundle))).responses,r=[];for(let i=0;i<n.length;i++){const o=n[i],a=e[i];try{const{decrypted:e}=Ae(o);r.push(await this.buildDecodedMessage(a,e,t))}catch(e){if(s)throw e;console.warn("Error decoding content",e)}}return r}async buildDecodedMessage(e,t,s){const{content:n,contentType:r,error:i,contentFallback:o}=await this.client.decodeContent(t);return Oe.fromV1Message(e,n,r,t,s,this,i,o)}async createMessage(e,t,s){return s=s||new Date,Ue.encode(this.client.keystore,e,this.client.publicKeyBundle,t,s)}}class _e{constructor(e,t,s,n,r,i){this.conversationVersion="v2",this.topic=t,this.createdAt=n,this.context=r,this.client=e,this.peerAddress=s,this.consentProof=i}get clientAddress(){return this.client.address}async allow(){await this.client.contacts.allow([this.peerAddress])}async deny(){await this.client.contacts.deny([this.peerAddress])}get isAllowed(){return this.client.contacts.isAllowed(this.peerAddress)}get isDenied(){return this.client.contacts.isDenied(this.peerAddress)}get consentState(){return this.client.contacts.consentState(this.peerAddress)}get consentProofPayload(){return this.consentProof}async messages(e){const t=await this.client.listEnvelopes(this.topic,this.processEnvelope.bind(this),e);return this.decryptBatch(t,!1)}messagesPaginated(e){return this.client.listEnvelopesPaginated(this.topic,this.decodeMessage.bind(this),e)}get ephemeralTopic(){return this.topic.replace("/xmtp/0/m","/xmtp/0/mE")}streamEphemeral(e){return le.create(this.client,[this.ephemeralTopic],this.decodeMessage.bind(this),void 0,e)}streamMessages(e){return le.create(this.client,[this.topic],this.decodeMessage.bind(this),void 0,e)}async send(e,t){const{payload:s,shouldPush:n}=await this.client.encodeContent(e,t),r=await this.createMessage(s,n,t?.timestamp),i=t?.ephemeral?this.ephemeralTopic:this.topic;await this.client.publishEnvelopes([{contentTopic:i,message:r.toBytes(),timestamp:r.sent}]);const o=t?.contentType||he;return"unknown"===this.consentState&&await this.allow(),Oe.fromV2Message(r,e,o,i,s,this,this.client.address)}async createMessage(e,t,s){const n={topic:this.topic,createdNs:ge(s||new Date)},r=o.MessageHeaderV2.encode(n).finish(),i=await M(me(r,e)),c={payload:e,sender:this.client.signedPublicKeyBundle,signature:await this.client.keystore.signDigest({digest:i,prekeyIndex:0,identityKey:void 0})},d=a.SignedContent.encode(c).finish(),{encrypted:h,senderHmac:y}=await this.encryptMessage(d,r),u={v1:void 0,v2:{headerBytes:r,ciphertext:h,senderHmac:y,shouldPush:t}},p=o.Message.encode(u).finish();return qe.create(u,n,p,y,t)}async decryptBatch(e,t=!1){const s=(await this.client.keystore.decryptV2(this.buildDecryptRequest(e))).responses,n=[];for(let r=0;r<s.length;r++){const i=s[r],o=e[r];try{const{decrypted:e}=Ae(i);n.push(await this.buildDecodedMessage(o,e))}catch(e){if(t)throw e;console.warn("Error decoding content",e)}}return n}buildDecryptRequest(e){return{requests:e.map((e=>({payload:e.ciphertext,headerBytes:e.headerBytes,contentTopic:this.topic})))}}async encryptMessage(e,t){const{responses:s}=await this.client.keystore.encryptV2({requests:[{payload:e,headerBytes:t,contentTopic:this.topic}]});if(1!==s.length)throw new Error("Invalid response length");const{encrypted:n,senderHmac:r}=Ae(s[0]);return{encrypted:n,senderHmac:r}}async buildDecodedMessage(e,t){const s=a.SignedContent.decode(t);if(!s.sender?.identityKey||!s.sender?.preKey||!s.signature)throw new Error("incomplete signed content");await async function(e){const t=e.sender?.preKey;if(!t||!t.signature||!t.keyBytes)throw new Error("missing pre-key or pre-key signature");const s=e.sender?.identityKey;if(!s)throw new Error("missing identity key in bundle");if(!await new re(s).verifyKey(new re(t)))throw new Error("pre key not signed by identity key")}(s);const n=await M(me(e.headerBytes,s.payload));if(!new re(s.sender?.preKey).verify(new Z(s.signature),n))throw new Error("invalid signature");const r=await new oe(s.sender).walletSignatureAddress(),{content:i,contentType:o,error:c,contentFallback:d}=await this.client.decodeContent(s.payload);return Oe.fromV2Message(e,i,o,this.topic,s.payload,this,r,c,d)}async prepareMessage(e,t){const{payload:s,shouldPush:n}=await this.client.encodeContent(e,t),r=await this.createMessage(s,n,t?.timestamp),i=r.toBytes(),o=t?.ephemeral?this.ephemeralTopic:this.topic,a={contentTopic:o,message:i,timestampNs:be(r.sent)};return new pe(a,(async()=>(await this.client.publishEnvelopes([{contentTopic:o,message:i,timestamp:r.sent}]),Oe.fromV2Message(r,e,t?.contentType||he,o,s,this,this.client.address))))}async processEnvelope(e){if(!e.message||!e.contentTopic)throw new Error("empty envelope");const t=o.Message.decode(e.message);if(!t.v2)throw new Error("unknown message version");const s=o.MessageHeaderV2.decode(t.v2.headerBytes);if(s.topic!==this.topic)throw new Error("topic mismatch");return qe.create(t,s,e.message,t.v2.senderHmac,t.v2.shouldPush)}async decodeMessage(e){if(!e.contentTopic)throw new Error("Missing content topic");const t=await this.processEnvelope(e),s=await this.decryptBatch([t],!0);if(!s.length)throw new Error("No results");return s[0]}}const xe=e=>{if(e.v1?.ciphertext)return[e.v1.headerBytes,new I(e.v1.ciphertext)];if(e.v2?.ciphertext)return[e.v2.headerBytes,new I(e.v2.ciphertext)];throw new Error("unknown message version")};class Ve{constructor(e,t,s){[this.headerBytes,this.ciphertext]=xe(s),this.id=e,this.bytes=t}toBytes(){return this.bytes}}class Ue extends Ve{constructor(e,t,s,n,r){super(e,t,s),this.conversation=void 0,this.senderAddress=r,this.header=n}static async create(e,t,s){if(!t.sender)throw new Error("missing message sender");const n=new ae(t.sender).walletSignatureAddress(),r=G(await M(s));return new Ue(r,s,e,t,n)}get sent(){return new Date(this.header.timestamp.toNumber())}get recipientAddress(){if(this.header?.recipient?.identityKey)return new ie(this.header.recipient.identityKey).walletSignatureAddress()}async decrypt(e,t){const s=(await e.decryptV1(Te([this],t))).responses;if(!s.length)throw new Error("No response from Keystore");const{decrypted:n}=Ae(s[0]);return n}static fromBytes(e){const t=o.Message.decode(e),[s]=xe(t),n=o.MessageHeaderV1.decode(s);if(!n)throw new Error("missing message header");if(!n.sender)throw new Error("missing message sender");if(!n.sender.identityKey)throw new Error("missing message sender identity key");if(!n.sender.preKey)throw new Error("missing message sender pre-key");if(!n.recipient)throw new Error("missing message recipient");if(!n.recipient.identityKey)throw new Error("missing message recipient identity-key");if(!n.recipient.preKey)throw new Error("missing message recipient pre-key");return Ue.create(t,n,e)}static async encode(e,t,s,n,r){const i={sender:s,recipient:n,timestamp:l.fromNumber(r.getTime())},a=o.MessageHeaderV1.encode(i).finish(),c=await e.encryptV1({requests:[{recipient:n,headerBytes:a,payload:t}]});if(!c.responses.length)throw new Error("No response from Keystore");const{encrypted:d}=Ae(c.responses[0]),h={v1:{headerBytes:a,ciphertext:d},v2:void 0},y=o.Message.encode(h).finish();return Ue.create(h,i,y)}}class qe extends Ve{constructor(e,t,s,n,r,i){super(e,t,s),this.header=n,this.senderHmac=r,this.shouldPush=i}static async create(e,t,s,n,r){const i=G(await M(s));return new qe(i,s,e,t,n,r)}get sent(){return ve(this.header.createdNs)}}class Oe{constructor({id:e,messageVersion:t,senderAddress:s,recipientAddress:n,conversation:r,contentBytes:i,contentType:o,contentTopic:a,content:c,sent:d,error:h,contentFallback:y}){this.id=e,this.messageVersion=t,this.senderAddress=s,this.recipientAddress=n,this.conversation=r,this.contentType=o,this.sent=d,this.error=h,this.content=c,this.contentTopic=a,this.contentBytes=i,this.contentFallback=y}toBytes(){return o.DecodedMessage.encode({...this,conversation:{topic:this.conversation.topic,context:this.conversation.context??void 0,createdNs:ge(this.conversation.createdAt),peerAddress:this.conversation.peerAddress,consentProofPayload:this.conversation.consentProof??void 0},sentNs:ge(this.sent)}).finish()}static async fromBytes(e,t){const s=o.DecodedMessage.decode(e),n=s.messageVersion;if("v1"!==n&&"v2"!==n)throw new Error("Invalid message version");if(!s.conversation)throw new Error("No conversation reference found");const{content:r,contentType:i,error:a,contentFallback:c}=await t.decodeContent(s.contentBytes);return new Oe({...s,content:r,contentType:i,error:a,messageVersion:n,sent:ve(s.sentNs),conversation:Le(s.conversation,t,n),contentFallback:c})}static fromV1Message(e,t,s,n,r,i,o,a){const{id:c,senderAddress:d,recipientAddress:h,sent:y}=e;if(!d)throw new Error("Sender address is required");return new Oe({id:c,messageVersion:"v1",senderAddress:d,recipientAddress:h,sent:y,content:t,contentBytes:n,contentType:s,contentTopic:r,conversation:i,error:o,contentFallback:a})}static fromV2Message(e,t,s,n,r,i,o,a,c){const{id:d,sent:h}=e;return new Oe({id:d,messageVersion:"v2",senderAddress:o,sent:h,content:t,contentBytes:r,contentType:s,contentTopic:n,conversation:i,error:a,contentFallback:c})}}function Le(e,t,s){if("v1"===s)return new Me(t,e.peerAddress,ve(e.createdNs));if("v2"===s)return new _e(t,e.topic,e.peerAddress,ve(e.createdNs),e.context,e.consentProofPayload);throw new Error(`Unknown conversation version ${s}`)}function He(e,t){return t.decodeContent(e)}class Fe extends Error{constructor(e){super(`no pre-key matches: ${G(e.secp256k1Uncompressed.bytes)}`)}}class Ge{constructor(e){if(this.version=2,!e.identityKey)throw new Error("missing identity key");this.identityKey=new J(e.identityKey),this.preKeys=(e.preKeys||[]).map((e=>new J(e)))}static async generate(e){const t=await J.generate(new te(e)),s=new Ge({identityKey:t,preKeys:[]});return await s.addPreKey(),s}getCurrentPreKey(){return this.preKeys[0]}findPreKey(e){const t=this.preKeys.find((t=>t.matches(e)));if(!t)throw new Fe(e);return t}async addPreKey(){this._publicKeyBundle=void 0;const e=await J.generate(this.identityKey);this.preKeys.unshift(e)}getPublicKeyBundle(){return this._publicKeyBundle||(this._publicKeyBundle=new oe({identityKey:this.identityKey.publicKey,preKey:this.getCurrentPreKey().publicKey})),this._publicKeyBundle}async sharedSecret(e,t,s){if(!e.identityKey||!e.preKey)throw new Error("invalid peer key bundle");if(!await e.identityKey.verifyKey(e.preKey))throw new Error("peer preKey signature invalid");if(!this.identityKey)throw new Error("missing identity key");let n,r,i;s?(i=this.findPreKey(t),n=i.sharedSecret(e.identityKey),r=this.identityKey.sharedSecret(e.preKey)):(i=this.findPreKey(t),n=this.identityKey.sharedSecret(e.preKey),r=i.sharedSecret(e.identityKey));const o=i.sharedSecret(e.preKey),a=new Uint8Array(n.length+r.length+o.length);return a.set(n,0),a.set(r,n.length),a.set(o,n.length+r.length),a}encode(){return t.PrivateKeyBundle.encode({v1:void 0,v2:this}).finish()}validatePublicKeys(){return!!this.identityKey.validatePublicKey()&&this.preKeys.every((e=>e.validatePublicKey()))}equals(e){if(this.preKeys.length!==e.preKeys.length)return!1;for(let t=0;t<this.preKeys.length;t++)if(!this.preKeys[t].equals(e.preKeys[t]))return!1;return this.identityKey.equals(e.identityKey)}static fromLegacyBundle(e){return new Ge({identityKey:J.fromLegacyKey(e.identityKey,!0),preKeys:e.preKeys.map((e=>J.fromLegacyKey(e)))})}}class $e{constructor(e){if(this.version=1,!e.identityKey)throw new Error("missing identity key");this.identityKey=new z(e.identityKey),this.preKeys=(e.preKeys||[]).map((e=>new z(e)))}static async generate(e){const t=z.generate();e&&await t.publicKey.signWithWallet(e);const s=new $e({identityKey:t,preKeys:[]});return await s.addPreKey(),s}getCurrentPreKey(){return this.preKeys[0]}findPreKey(e){const t=this.preKeys.find((t=>t.matches(e)));if(!t)throw new Fe(e);return t}async addPreKey(){this._publicKeyBundle=void 0;const e=z.generate();await this.identityKey.signKey(e.publicKey),this.preKeys.unshift(e)}getPublicKeyBundle(){return this._publicKeyBundle||(this._publicKeyBundle=new ae({identityKey:this.identityKey.publicKey,preKey:this.getCurrentPreKey().publicKey})),this._publicKeyBundle}validatePublicKeys(){return!!this.identityKey.validatePublicKey()&&this.preKeys.every((e=>e.validatePublicKey()))}async sharedSecret(e,t,s){if(!e.identityKey||!e.preKey)throw new Error("invalid peer key bundle");if(!await e.identityKey.verifyKey(e.preKey))throw new Error("peer preKey signature invalid");if(!this.identityKey)throw new Error("missing identity key");let n,r,i;s?(i=this.findPreKey(t),n=i.sharedSecret(e.identityKey),r=this.identityKey.sharedSecret(e.preKey)):(i=this.findPreKey(t),n=this.identityKey.sharedSecret(e.preKey),r=i.sharedSecret(e.identityKey));const o=i.sharedSecret(e.preKey),a=new Uint8Array(n.length+r.length+o.length);return a.set(n,0),a.set(r,n.length),a.set(o,n.length+r.length),a}encode(){return t.PrivateKeyBundle.encode({v1:this,v2:void 0}).finish()}}function je(e){const s=t.PrivateKeyBundle.decode(e);if(s.v1)return new $e(s.v1);if(s.v2)return new Ge(s.v2);throw new Error("unknown private key bundle version")}class Xe{constructor({walletAddr:e,createdNs:t}){this.walletAddr=e,this.createdNs=t}static create(e,t){return t=t||new Date,new Xe({walletAddr:e,createdNs:ge(t)})}static fromBytes(e){const t=c.AuthData.decode(e);return new Xe(t)}toBytes(){return c.AuthData.encode(this).finish()}}class Je{constructor({identityKey:e,authDataBytes:t,authDataSignature:s}){if(!e)throw new Error("Missing identity key in token");if(!s)throw new Error("Missing authDataSignature in token");this.identityKey=e,this.authDataBytes=t,this.authDataSignature=s}get authData(){return this._authData||(this._authData=Xe.fromBytes(this.authDataBytes)),this._authData}get ageMs(){return(new Date).valueOf()-this.authData.createdNs.div(1e6).toNumber()}toBytes(){return c.Token.encode(this).finish()}static fromBytes(e){return new Je(c.Token.decode(e))}toBase64(){return Buffer.from(this.toBytes()).toString("base64")}}class ze{constructor(e){this.keystore=e}async createToken(e){return(e=>e instanceof Je?e:new Je(e))(await this.keystore.createAuthToken({timestampNs:e?ge(e):void 0}))}}const Ye=e=>new Promise((t=>setTimeout(t,e))),We=e=>!!e;async function Qe(e,t,s,n,r=We,i=1){const o="number"==typeof i?i:1;try{return await e(...t)}catch(i){if(!r(i)||o>s)throw i;return await Ye(n),Qe(e,t,s,n,r,o+1)}}async function*Ze(e,t){for await(const s of e){const e=await Promise.allSettled(s.map(t)),n=[];for(const t of e)"fulfilled"===t.status?n.push(t.value):console.warn("Failed to process envelope due to reason: ",t.reason);yield n}}class et{constructor(e,t=3590){this.authenticator=e,this.maxAgeMs=1e3*t}async getToken(){return(!this.token||this.token.ageMs>this.maxAgeMs)&&await this.refresh(),this.token.toBase64()}async refresh(){this.token=await this.authenticator.createToken()}}const{MessageApi:tt,SortDirection:st}=d,nt={local:"http://localhost:5555",dev:"https://dev.xmtp.network",production:"https://production.xmtp.network"};var rt;!function(e){e[e.OK=0]="OK",e[e.CANCELLED=1]="CANCELLED",e[e.UNKNOWN=2]="UNKNOWN",e[e.INVALID_ARGUMENT=3]="INVALID_ARGUMENT",e[e.DEADLINE_EXCEEDED=4]="DEADLINE_EXCEEDED",e[e.NOT_FOUND=5]="NOT_FOUND",e[e.ALREADY_EXISTS=6]="ALREADY_EXISTS",e[e.PERMISSION_DENIED=7]="PERMISSION_DENIED",e[e.RESOURCE_EXHAUSTED=8]="RESOURCE_EXHAUSTED",e[e.FAILED_PRECONDITION=9]="FAILED_PRECONDITION",e[e.ABORTED=10]="ABORTED",e[e.OUT_OF_RANGE=11]="OUT_OF_RANGE",e[e.UNIMPLEMENTED=12]="UNIMPLEMENTED",e[e.INTERNAL=13]="INTERNAL",e[e.UNAVAILABLE=14]="UNAVAILABLE",e[e.DATA_LOSS=15]="DATA_LOSS",e[e.UNAUTHENTICATED=16]="UNAUTHENTICATED"}(rt||(rt={}));class it extends Error{constructor(e,t){super(e),this.code=t}static fromObject(e){return new it(e.message,e.code)}}const ot=e=>!!e&&!("AbortError"!==e.name&&!e.message.includes("aborted")),at=e=>!(e=>!(!e||!("code"in e)||16!==e.code))(e),ct=e=>e.message&&e.message.length?("string"==typeof e.message&&(e.message=we(e.message)),e):e;class dt{constructor(e,t){this.pathPrefix=e,this.maxRetries=t?.maxRetries||5,this.appVersion=t?.appVersion,this.version="xmtp-js/11.6.3",e===nt.dev&&console.info("\nXX    XX MM    MM TTTTTT PPPPPP   DDDDD   EEEEEEE VV     VV \n XX  XX  MMM  MMM   TT   PP   PP  DD  DD  EE      VV     VV \n  XXXX   MM MM MM   TT   PPPPPP   DD   DD EEEEE    VV   VV  \n XX  XX  MM    MM   TT   PP       DD   DD EE        VV VV   \nXX    XX MM    MM   TT   PP       DDDDDD  EEEEEEE    VVV    \n\nConnected to the XMTP 'dev' network. Use 'production' for production messages.\nhttps://github.com/xmtp/xmtp-js#xmtp-production-and-dev-network-environments\n")}async _query(e){try{return await Qe(tt.Query,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:this.headers()}],this.maxRetries,100)}catch(e){throw it.fromObject(e)}}_batchQuery(e){return Qe(tt.BatchQuery,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:this.headers()}],this.maxRetries,100)}async _publish(e,t=0){const s=await this.getToken(),n=this.headers();n.set("Authorization",`Bearer ${s}`);try{return await Qe(tt.Publish,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:n}],this.maxRetries,100,at)}catch(s){if(at(s)||t>=1)throw it.fromObject(s);return await(this.authCache?.refresh()),this._publish(e,t+1)}}_subscribe(e,t,s){const n=new AbortController;return(async()=>{for(;;){const r=(new Date).getTime();try{if(await tt.Subscribe(e,t,{pathPrefix:this.pathPrefix,signal:n.signal,mode:"cors",headers:this.headers()}),n.signal.aborted)return;console.info("Stream connection closed. Resubscribing"),(new Date).getTime()-r<1e3&&await Ye(1e3),s?.()}catch(e){if(ot(e)||n.signal.aborted)return;console.info("Stream connection closed. Resubscribing"),(new Date).getTime()-r<1e3&&await Ye(1e3),s?.()}}})(),{unsubscribe:async()=>{n?.abort()}}}async query(e,{direction:t=st.SORT_DIRECTION_ASCENDING,limit:s}){const n=[];for await(const r of this.queryIteratePages(e,{direction:t,pageSize:s&&s<100?s:100}))for(const e of r)if(n.push(e),s&&n.length===s)return n;return n}async*queryIterator(e,t){for await(const s of this.queryIteratePages(e,t))for(const e of s)yield e}async*queryIteratePages({contentTopic:e,startTime:t,endTime:s},{direction:n,pageSize:r=10}){if(!e||!e.length)throw new Error("Must specify content topics");const i=be(t),o=be(s);let a;for(;;){const t={limit:r,direction:n,cursor:a},s=await this._query({contentTopics:[e],startTimeNs:i,endTimeNs:o,pagingInfo:t});if(!s.envelopes?.length)return;if(yield s.envelopes.map(ct),!s.pagingInfo?.cursor)return;a=s.pagingInfo?.cursor}}async batchQuery(e){const t=[];for(let s=0;s<e.length;s+=50){const n=e.slice(s,s+50),r=[];for(const e of n)r.push({contentTopics:[e.contentTopic],startTimeNs:be(e.startTime),endTimeNs:be(e.endTime),pagingInfo:{limit:e.pageSize||10,direction:e.direction||st.SORT_DIRECTION_ASCENDING}});const i={requests:r};t.push(i)}const s=await Promise.all(t.map((async e=>this._batchQuery(e)))),n=[];for(const e of s){if(!e.responses)throw new Error("BatchQueryResponse missing responses");for(const t of e.responses)t.envelopes?n.push(t.envelopes.map(ct)):n.push([])}return n}async publish(e){const t=[];for(const{contentTopic:s,message:n,timestamp:r}of e){if(!s.length)throw new Error("Content topic cannot be empty string");if(!n.length)throw new Error("0 length messages not allowed");const e=r||new Date;t.push({contentTopic:s,timestampNs:be(e),message:Uint8Array.from(n)})}return this._publish({envelopes:t})}subscribe(e,t,s){if(!e.contentTopics.length)throw new Error("Must provide list of contentTopics to subscribe to");return this._subscribe(e,(e=>t(ct(e))),s)}getToken(){if(!this.authCache)throw new Error("AuthCache is not set on API Client");return this.authCache.getToken()}setAuthenticator(e,t){this.authCache=new et(e,t)}headers(){const e=new Headers;return e.set("X-Client-Version",this.version),this.appVersion&&e.set("X-App-Version",this.appVersion),e}}class ht{constructor(e,t){this.disableOffset=!1,this.jobType=e,this.mutex=new A,this.keystore=t}get protoJobType(){return function(e){const t={v1:i.JobType.JOB_TYPE_REFRESH_V1,v2:i.JobType.JOB_TYPE_REFRESH_V2,"user-preferences":i.JobType.JOB_TYPE_REFRESH_PPPP}[e];if(!t)throw new Error(`unknown job type: ${e}`);return t}(this.jobType)}async run(e){return this.mutex.runExclusive((async()=>{const t=await this.getLastRunTime(),s=new Date,n=await e(t?this.disableOffset?t:new Date(t.getTime()-1e4):void 0);return await this.setLastRunTime(s),n}))}async resetLastRunTime(){await this.keystore.setRefreshJob({jobType:this.protoJobType,lastRunNs:ge(new Date(0))})}async getLastRunTime(){const{lastRunNs:e}=await this.keystore.getRefreshJob(i.GetRefreshJobRequest.fromPartial({jobType:this.protoJobType}));if(!e.equals(l.fromNumber(0)))return ve(e)}async setLastRunTime(e){await this.keystore.setRefreshJob({jobType:this.protoJobType,lastRunNs:ge(e)})}}const yt=e=>Boolean(e.recipientAddress&&e.senderAddress);class ut{constructor(e){this.client=e,this.v1JobRunner=new ht("v1",e.keystore),this.v2JobRunner=new ht("v2",e.keystore)}async list(){const[e,t]=await Promise.all([this.listV1Conversations(),this.listV2Conversations()]),s=e.concat(t);return s.sort(((e,t)=>e.createdAt.getTime()-t.createdAt.getTime())),s}async listFromCache(){const[e,t]=await Promise.all([this.getV1ConversationsFromKeystore(),this.getV2ConversationsFromKeystore()]),s=e.concat(t);return s.sort(((e,t)=>e.createdAt.getTime()-t.createdAt.getTime())),s}async listV1Conversations(){return this.v1JobRunner.run((async e=>{const t=await this.getIntroductionPeers({startTime:e,direction:st.SORT_DIRECTION_ASCENDING});return await this.client.keystore.saveV1Conversations({conversations:Array.from(t).map((([e,t])=>({peerAddress:e,createdNs:ge(t),topic:Se(e,this.client.address),context:void 0,consentProofPayload:void 0}))).filter((e=>De(e.topic)))}),(await this.client.keystore.getV1Conversations()).conversations.map(this.conversationReferenceToV1.bind(this))}))}async listV2Conversations(){return this.v2JobRunner.run((async e=>{const t=await this.getV2ConversationsFromKeystore(),s=await this.updateV2Conversations(e),n=new Set(t.map((e=>e.topic)));for(const e of s)n.has(e.topic)||(t.push(e),n.add(e.topic));return t.sort(((e,t)=>e.createdAt.getTime()-t.createdAt.getTime())),t}))}async getV2ConversationsFromKeystore(){return(await this.client.keystore.getV2Conversations()).conversations.map(this.conversationReferenceToV2.bind(this))}async getV1ConversationsFromKeystore(){return(await this.client.keystore.getV1Conversations()).conversations.map(this.conversationReferenceToV1.bind(this))}async updateV2Conversations(e){const t=await this.client.listInvitations({startTime:e,direction:st.SORT_DIRECTION_ASCENDING});return this.decodeInvites(t)}async decodeInvites(e,t=!1){const{responses:s}=await this.client.keystore.saveInvites({requests:e.map((e=>({payload:e.message,timestampNs:l.fromString(e.timestampNs),contentTopic:e.contentTopic}))).filter((e=>De(e.contentTopic)))}),n=[];for(const e of s)try{n.push(this.saveInviteResponseToConversation(e))}catch(e){if(console.warn("Error saving invite response to conversation: ",e),t)throw e}return n}saveInviteResponseToConversation({result:e,error:t}){if(t||!e||!e.conversation)throw new Error(`Error from keystore: ${t?.code} ${t?.message}}`);return this.conversationReferenceToV2(e.conversation)}conversationReferenceToV2(e){return new _e(this.client,e.topic,e.peerAddress,ve(e.createdNs),e.context,e.consentProofPayload)}conversationReferenceToV1(e){return new Me(this.client,e.peerAddress,ve(e.createdNs))}async stream(e){const t=new Set,s=Be(this.client.address),n=Ie(this.client.address),r=[s,n];return le.create(this.client,r,(async e=>{if(e.contentTopic===s){if(!e.message)throw new Error("empty envelope");const s=await Ue.fromBytes(e.message),n=this.getPeerAddress(s);if(!(e=>!t.has(e)&&(t.add(e),!0))(n))return;return await s.decrypt(this.client.keystore,this.client.publicKeyBundle),new Me(this.client,n,s.sent)}if(e.contentTopic===n){const t=await this.decodeInvites([e],!0);if(t.length)return t[0]}throw new Error("unrecognized invite topic")}).bind(this),void 0,e)}async streamAllMessages(e){const t=Be(this.client.address),s=Ie(this.client.address),n=new Set([t,s]),r=new Map;for(const e of await this.list())n.add(e.topic),r.set(e.topic,e);const i=(e,t)=>!n.has(e)&&(r.set(e,t),n.add(e),!0),o=await le.create(this.client,Array.from(n.values()),(async e=>{const n=e.contentTopic;if(!n||!e.message)return null;if(n===t){const t=await Ue.fromBytes(e.message);if(!yt(t))return null;const s=this.getPeerAddress(t);return new Me(this.client,s,t.sent).decodeMessage(e)}if(n===s){return(await this.decodeInvites([e],!0))[0]}const i=r.get(n);if(i instanceof Me)return i.decodeMessage(e);if(i instanceof _e)return i.decodeMessage(e);throw console.log("Unknown topic"),new Error("Unknown topic")}),(e=>{if(e instanceof Oe&&e.contentTopic===t){const t=new Me(this.client,e.recipientAddress?.toLowerCase()===this.client.address.toLowerCase()?e.senderAddress:e.recipientAddress,e.sent);return i(t.topic,t)?Array.from(n.values()):void 0}if(e instanceof _e){return i(e.topic,e)?Array.from(n.values()):void 0}}),e),a=async function*(){for await(const e of o)if(e instanceof Oe&&(yield e),e instanceof _e)for(const t of await e.messages())yield t}();return a.return=async()=>(await(o?.return()),{value:void 0,done:!0}),a}async getIntroductionPeers(e){const t=Be(this.client.address),s=await this.client.listEnvelopes(t,(e=>{if(!e.message)throw new Error("empty envelope");return Ue.fromBytes(e.message)}),e),n=new Map;for(const e of s){if(!yt(e))continue;const t=this.getPeerAddress(e);if(t){const s=n.get(t);if(!s||s>e.sent)try{await e.decrypt(this.client.keystore,this.client.publicKeyBundle),n.set(t,e.sent)}catch(e){continue}}}return n}async newConversation(e,t,s){const n=s=>{return s.peerAddress.toLowerCase()===e.toLowerCase()&&(n=t,r=s.context??void 0,n?.conversationId===r?.conversationId);var n,r},r=(await this.getV2ConversationsFromKeystore()).find(n);if(r)return r;let i=await this.client.getUserContact(e);if(!i)throw new Error(`Recipient ${e} is not on the XMTP network`);if(e.toLowerCase()===this.client.address.toLowerCase())throw new Error("self messaging not supported");if(i instanceof ae&&!t?.conversationId)return new Me(this.client,e,new Date);if(!t?.conversationId){const t=(await this.listV1Conversations()).find((t=>t.peerAddress.toLowerCase()===e.toLowerCase()));if(t){if(!this.client.signedPublicKeyBundle.isFromLegacyBundle())throw new Error("cannot resume pre-existing V1 conversation; client keys not compatible");if(!(i instanceof ae||i.isFromLegacyBundle()))throw new Error("cannot resume pre-existing V1 conversation; peer keys not compatible");return t}}return i instanceof ae&&(i=oe.fromLegacyBundle(i)),this.v2JobRunner.run((async e=>{const r=(await this.updateV2Conversations(e)).find(n);return r||this.createV2Convo(i,t,s)}))}async createV2Convo(e,t,s){const n=new Date,{payload:r,conversation:i}=await this.client.keystore.createInvite({recipient:e,context:t,createdNs:ge(n),consentProof:s});if(!r||!i)throw new Error("Required field not returned from Keystore");const o=await e.walletSignatureAddress();return await this.client.publishEnvelopes([{contentTopic:Ie(o),message:r,timestamp:n},{contentTopic:Ie(this.client.address),message:r,timestamp:n}]),await this.client.contacts.allow([o]),this.conversationReferenceToV2(i)}getPeerAddress(e){return e.recipientAddress?.toLowerCase()===this.client.address.toLowerCase()?e.senderAddress:e.recipientAddress}}class pt{constructor(e){this.storage=e}static create(){if("undefined"==typeof localStorage)throw new Error("Missing LocalStorage. Use ephemeralPersistence instead");return new pt(localStorage)}async getItem(e){const t=this.storage.getItem(e);return null===t?null:Uint8Array.from(Buffer.from(t,"binary"))}async setItem(e,t){this.storage.setItem(e,Buffer.from(t).toString("binary"))}}class lt{constructor(){this.store=new Map}get length(){return this.store.size}clear(){this.store=new Map}getItem(e){return this.validateString(e),this.store.has(e)?String(this.store.get(e)):null}key(e){if(void 0===e)throw new TypeError("Failed to execute 'key' on 'Storage': 1 argument required, but only 0 present.");const t=[...this.store.keys()];return e>=t.length?null:t[e]}removeItem(e){this.validateString(e),this.store.delete(e)}setItem(e,t){this.validateString(e),this.validateString(t),this.store.set(String(e),String(t))}validateString(e){if("string"!=typeof e)throw new TypeError("Key must be a string")}}class wt extends pt{static create(){return new pt(new lt)}}class ft extends Error{}class mt{constructor(e){if(!e.publicKey.signature)throw new Error("Provided public key is not signed");this.identityKey=e}async createToken(e){const t=Xe.create(this.identityKey.publicKey.walletSignatureAddress(),e||new Date).toBytes(),r=m(t),i=await this.identityKey.sign(b(r));return new Je(c.Token.fromPartial({identityKey:n.PublicKey.fromPartial(this.identityKey.publicKey),authDataBytes:t,authDataSignature:s.Signature.fromPartial(i)}))}}const gt=new(0,T.ec)("secp256k1"),vt=R.subtle,bt=Buffer.from("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141","hex"),Et=Buffer.alloc(32,0);function Kt(e,t){if(!e)throw new Error(t||"Assertion failed")}function At(e){return t=e,!(!Buffer.isBuffer(t)||32!==t.length)&&(e.compare(Et)>0&&e.compare(bt)<0);var t}function Tt(e){const t=new Uint8Array(e);return R.getRandomValues(t),Buffer.from(t)}async function kt(e){const t=await vt.digest("SHA-512",e);return Buffer.from(t)}function St(e){return function(t,s,n){return new Promise((function(r){return vt.importKey("raw",s,{name:"AES-CBC"},!1,[e]).then((function(s){const r={name:"AES-CBC",iv:t};return vt[e](r,s,n)})).then((function(e){r(Buffer.from(new Uint8Array(e)))}))}))}}const Pt=St("encrypt"),Ct=St("decrypt");async function Bt(e,t){const s=await vt.importKey("raw",e,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]);return Buffer.from(await vt.sign({name:"HMAC",hash:"SHA-256"},s,t))}function It(e){return Kt(32===e.length,"Bad private key"),Kt(At(e),"Bad private key"),Buffer.from(gt.keyFromPrivate(e).getPublic("array"))}function Rt(e,t){return new Promise((function(s){Kt(Buffer.isBuffer(e),"Bad private key"),Kt(Buffer.isBuffer(t),"Bad public key"),Kt(32===e.length,"Bad private key"),Kt(At(e),"Bad private key"),Kt(65===t.length||33===t.length,"Bad public key"),65===t.length&&Kt(4===t[0],"Bad public key"),33===t.length&&Kt(2===t[0]||3===t[0],"Bad public key");const n=gt.keyFromPrivate(e),r=gt.keyFromPublic(t),i=n.derive(r.getPublic());s(Buffer.from(i.toArray()))}))}async function Nt(e,t){const s=await Rt(e,t.ephemeralPublicKey),n=await kt(s),r=n.slice(0,32),i=n.slice(32),o=Buffer.concat([t.iv,t.ephemeralPublicKey,t.ciphertext]);return Kt(await async function(e,t,s){return function(e,t){if(e.length!==t.length)return!1;let s=0;for(let n=0;n<e.length;n++)s|=e[n]^t[n];return 0===s}(await Bt(e,t),s)}(i,o,t.mac),"Bad mac"),Ct(t.iv,r,t.ciphertext)}async function Dt(e,t){await k();const s=e.publicKey.secp256k1Uncompressed.bytes,n=e.secp256k1.bytes;return S(s,n,t)}async function Mt(e,t){await k();const s=e.publicKey.secp256k1Uncompressed.bytes,n=e.secp256k1.bytes;return P(s,n,t)}class _t{constructor({topic:e,context:t,aes256GcmHkdfSha256:s,consentProof:n}){if(!e||!e.length)throw new Error("Missing topic");if(!s||!s.keyMaterial||!s.keyMaterial.length)throw new Error("Missing key material");this.topic=e,this.context=t,this.aes256GcmHkdfSha256=s,this.consentProof=n}static createRandom(e,t){const s=Pe(Buffer.from(R.getRandomValues(new Uint8Array(32))).toString("base64").replace(/=*$/g,"").replace(/\//g,"-")),n=R.getRandomValues(new Uint8Array(32));return new _t({topic:s,aes256GcmHkdfSha256:{keyMaterial:n},context:e,consentProof:t})}toBytes(){return h.InvitationV1.encode(this).finish()}static fromBytes(e){return new _t(h.InvitationV1.decode(e))}}class xt{constructor({sender:e,recipient:t,createdNs:s}){if(!e)throw new Error("Missing sender");if(!t)throw new Error("Missing recipient");this.sender=new oe(e),this.recipient=new oe(t),this.createdNs=s}toBytes(){return h.SealedInvitationHeaderV1.encode(this).finish()}static fromBytes(e){return new xt(h.SealedInvitationHeaderV1.decode(e))}}class Vt{constructor({headerBytes:e,ciphertext:t}){if(!e||!e.length)throw new Error("Missing header bytes");if(!t)throw new Error("Missing ciphertext");this.headerBytes=e,this.ciphertext=new I(t)}get header(){return this._header||(this._header=xt.fromBytes(this.headerBytes)),this._header}async getInvitation(e){if(this._invitation)return this._invitation;const t=this.header;let s;s=e.identityKey.matches(this.header.sender.identityKey)?await e.sharedSecret(t.recipient,t.sender.preKey,!1):await e.sharedSecret(t.sender,t.recipient.preKey,!0);const n=await x(this.ciphertext,s,this.headerBytes);return this._invitation=_t.fromBytes(n),this._invitation}toBytes(){return h.SealedInvitationV1.encode(this).finish()}static fromBytes(e){return new Vt(h.SealedInvitationV1.decode(e))}}class Ut{constructor({v1:e}){if(!e)throw new Error("Missing v1 or v2 invitation");this.v1=new Vt(e)}toBytes(){return h.SealedInvitation.encode(this).finish()}static fromBytes(e){return new Ut(h.SealedInvitation.decode(e))}static async fromEnvelope(e){if(!e.message||!e.timestampNs)throw new Error("invalid invitation envelope");const t=Ut.fromBytes(e.message),s=l.fromString(e.timestampNs),n=t.v1?.header.createdNs;if(!n||!n.equals(s))throw new Error("envelope and header timestamp mistmatch");return t}static async createV1({sender:e,recipient:t,created:s,invitation:n}){const r=new xt({sender:e.getPublicKeyBundle(),recipient:t,createdNs:ge(s)}).toBytes(),i=await e.sharedSecret(t,e.getCurrentPreKey().publicKey,!1),o=n.toBytes(),a=await _(o,i,r);return new Ut({v1:{headerBytes:r,ciphertext:a}})}}const qt=(e,t)=>e instanceof Ke?e:new Ke(t,e.message),Ot=(e,t,s)=>Promise.all(e.map((async e=>{try{return{result:await t(e)}}catch(e){return{error:qt(e,s)}}}))),Lt=e=>e instanceof ae?e:new ae(e),Ht=(e,t,s)=>{for(const s of t)if(!e[s])throw new Ke(i.ErrorCode.ERROR_CODE_INVALID_INPUT,`Missing field ${String(s)}`);for(const t of s){const s=e[t];if(!s||!s?.length)throw new Ke(i.ErrorCode.ERROR_CODE_INVALID_INPUT,`Missing field ${String(t)}`)}return!0},Ft=e=>{if(!e?.aes256GcmHkdfSha256?.keyMaterial)throw new Ke(i.ErrorCode.ERROR_CODE_INVALID_INPUT,"Missing key material");return e.aes256GcmHkdfSha256.keyMaterial},Gt=({invitation:e,createdNs:t,peerAddress:s})=>({context:e.context,topic:e.topic,peerAddress:s,createdNs:t,consentProofPayload:e.consentProof});class $t{constructor(e,t,s=new Map){this.persistenceKey=t,this.persistence=e,this.revision=0,this.mutex=new A,this.topicMap=s}get revisionKey(){return this.persistenceKey+"/revision"}static async create(e){const t=new $t(e,"invitations/v1");return await t.refresh(),t}validate(e){return!!e.topic&&e.topic.length>0&&!!e.invitation}async refresh(){const e=await this.getRevision();if(e>this.revision)for(const[e,t]of await this.loadFromPersistence())this.topicMap.set(e,t);this.revision=e}async getRevision(){const e=await this.persistence.getItem(this.revisionKey);return e?function(e){const t=e.buffer;return new DataView(t).getInt32(0,!0)}(e):0}async setRevision(e){await this.persistence.setItem(this.revisionKey,function(e){const t=new ArrayBuffer(4);return new DataView(t).setInt32(0,e,!0),new Uint8Array(t)}(e))}async loadFromPersistence(){const e=await this.persistence.getItem(this.persistenceKey);return e?(e=>{const t=new Map;for(const[s,n]of Object.entries(e.topics))t.set(s,n);return t})(i.TopicMap.decode(e)):new Map}async store(){await this.persistence.setItem(this.persistenceKey,this.toBytes()),this.revision++,await this.setRevision(this.revision)}async add(e){await this.mutex.runExclusive((async()=>{await this.refresh();let t=!1;for(const s of e){if(!this.validate(s)){console.warn("Invalid topic data",s.topic);continue}const{topic:e,...n}=s;this.topicMap.has(e)||(this.topicMap.set(e,n),t=!0)}t&&await this.store()}))}get topics(){return[...this.topicMap.values()]}lookup(e){return this.topicMap.get(e)}toBytes(){return i.TopicMap.encode({topics:Object.fromEntries(this.topicMap)}).finish()}}class jt extends $t{static async create(e){const t=new jt(e,"conversation-v1/v1");return await t.refresh(),t}validate(e){return!!(e.topic&&e.topic.length&&e.peerAddress?.length>0)}}const Xt=async(e,t,s,n)=>_(s,await e.sharedSecret(t,e.getCurrentPreKey().publicKey,!1),n),{ErrorCode:Jt}=i,zt=(new TextEncoder).encode("__XMTP__INVITATION__SALT__XMTP__");class Yt{constructor(e,t,s,n){this.v1Keys=e,this.v2Keys=Ge.fromLegacyBundle(e),this.v1Store=t,this.v2Store=s,this.authenticator=new mt(e.identityKey),this.jobStatePersistence=n}static async create(e,t){return new Yt(e,await jt.create(t),await $t.create(t),t)}get walletAddress(){return this.v1Keys.identityKey.publicKey.walletSignatureAddress()}async decryptV1(e){const t=await Ot(e.requests,(async e=>{Ht(e,["payload","peerKeys"],["headerBytes"]);const{payload:t,peerKeys:s,headerBytes:n,isSender:r}=e,i=await(async(e,t,s,n,r)=>x(s,await e.sharedSecret(t,e.getCurrentPreKey().publicKey,!r),n))(this.v1Keys,Lt(s),t,n,r);return{decrypted:i}}),i.ErrorCode.ERROR_CODE_UNSPECIFIED);return i.DecryptResponse.fromPartial({responses:t})}async decryptV2(e){const t=await Ot(e.requests,(async e=>{Ht(e,["payload"],["headerBytes"]);const{payload:t,headerBytes:s,contentTopic:n}=e,r=this.v2Store.lookup(n);if(!r)throw new Ke(i.ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY,"no topic key");const o=await((e,t,s)=>x(e,t,s))(t,Ft(r.invitation),s);return{decrypted:o}}),Jt.ERROR_CODE_UNSPECIFIED);return i.DecryptResponse.fromPartial({responses:t})}async encryptV1(e){const t=await Ot(e.requests,(async e=>{Ht(e,["payload","recipient"],["headerBytes"]);const{recipient:t,payload:s,headerBytes:n}=e;return{encrypted:await Xt(this.v1Keys,Lt(t),s,n)}}),Jt.ERROR_CODE_UNSPECIFIED);return i.EncryptResponse.fromPartial({responses:t})}async createAuthToken({timestampNs:e}){return this.authenticator.createToken(e?ve(e):void 0)}async selfEncrypt(e){const t=await Ot(e.requests,(async e=>{const{payload:t}=e;if(!t)throw new Ke(Jt.ERROR_CODE_INVALID_INPUT,"Missing field payload");return{encrypted:await Dt(this.v1Keys.identityKey,t)}}),Jt.ERROR_CODE_INVALID_INPUT);return i.SelfEncryptResponse.fromPartial({responses:t})}async selfDecrypt(e){const t=await Ot(e.requests,(async e=>{const{payload:t}=e;if(!t)throw new Ke(Jt.ERROR_CODE_INVALID_INPUT,"Missing field payload");return{decrypted:await Mt(this.v1Keys.identityKey,t)}}),Jt.ERROR_CODE_INVALID_INPUT);return i.DecryptResponse.fromPartial({responses:t})}async getPrivatePreferencesTopicIdentifier(){const e=await async function(e){await k();const t=e.secp256k1.bytes;return C(t)}(this.v1Keys.identityKey);return i.GetPrivatePreferencesTopicIdentifierResponse.fromPartial({identifier:e})}async encryptV2(e){const t=await Ot(e.requests,(async e=>{Ht(e,["payload"],["headerBytes"]);const{payload:t,headerBytes:s,contentTopic:n}=e,r=this.v2Store.lookup(n);if(!r)throw new Ke(Jt.ERROR_CODE_NO_MATCHING_PREKEY,"no topic key");const i=Ft(r.invitation),o=await((e,t,s)=>_(e,t,s))(t,i,s),a=`${Math.floor(Date.now()/1e3/60/60/24/30)}-${await this.getAccountAddress()}`;return{encrypted:o,senderHmac:await O(i,(new TextEncoder).encode(a),s)}}),Jt.ERROR_CODE_INVALID_INPUT);return i.EncryptResponse.fromPartial({responses:t})}async saveInvites(e){const t=[],s=await Ot(e.requests,(async({payload:e,timestampNs:s})=>{const n=Ut.fromBytes(e);if(n.v1){if(!n.v1.header.createdNs.equals(s))throw new Error("envelope and header timestamp mismatch");const e=n.v1.header.sender.equals(this.v2Keys.getPublicKeyBundle()),r=await n.v1.getInvitation(this.v2Keys),i={invitation:r,createdNs:n.v1.header.createdNs,peerAddress:e?await n.v1.header.recipient.walletSignatureAddress():await n.v1.header.sender.walletSignatureAddress()};return t.push({...i,topic:r.topic}),{conversation:Gt(i)}}}),Jt.ERROR_CODE_INVALID_INPUT);return await this.v2Store.add(t),i.SaveInvitesResponse.fromPartial({responses:s})}async createInvite(e){try{Ht(e,["recipient"],[]);const s=ve(e.createdNs),n=(t=e.recipient)instanceof oe?t:new oe(t),r=await this.getAccountAddress(),o=await n.walletSignatureAddress(),a=await this.v2Keys.sharedSecret(n,this.v2Keys.getCurrentPreKey().publicKey,r<o),c=[r,o].sort(),d=(e.context?.conversationId||"")+c.join(),h=(new TextEncoder).encode(d),y=G(await Bt(Buffer.from(a),Buffer.from(h))),u=["0",...c].join("|"),p=(new TextEncoder).encode(u),l=await async function(e,t){const s=await R.subtle.importKey("raw",e,"HKDF",!1,["deriveKey"]);return R.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:zt,info:t},s,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}(a,p),w=new Uint8Array(await R.subtle.exportKey("raw",l)),f=new _t({topic:Pe(y),aes256GcmHkdfSha256:{keyMaterial:w},context:e.context,consentProof:e.consentProof}),m=await Ut.createV1({sender:this.v2Keys,recipient:n,created:s,invitation:f}),g={invitation:f,topic:f.topic,createdNs:e.createdNs,peerAddress:await n.walletSignatureAddress()};return await this.v2Store.add([g]),i.CreateInviteResponse.fromPartial({conversation:Gt(g),payload:m.toBytes()})}catch(e){throw qt(e,Jt.ERROR_CODE_INVALID_INPUT)}var t}async signDigest(e){Ht(e,["digest"],[]);const{digest:t,identityKey:s,prekeyIndex:n}=e;let r;if(s)r=this.v1Keys.identityKey;else{if(void 0===n||!Number.isInteger(n))throw new Ke(Jt.ERROR_CODE_INVALID_INPUT,"must specifify identityKey or prekeyIndex");if(r=this.v1Keys.preKeys[n],!r)throw new Ke(Jt.ERROR_CODE_NO_MATCHING_PREKEY,"no prekey found")}return r.sign(t)}async saveV1Conversations({conversations:e}){return await this.v1Store.add(e.map((e=>({topic:Se(e.peerAddress,this.walletAddress),peerAddress:e.peerAddress,createdNs:e.createdNs,invitation:void 0})))),{}}async getV1Conversations(){return{conversations:this.v1Store.topics.map(this.topicDataToV1ConversationReference.bind(this))}}async getV2Conversations(){const e=this.v2Store.topics.map((e=>Gt(e)));return e.sort(((e,t)=>e.createdNs.div(1e6).sub(t.createdNs.div(1e6)).toNumber())),i.GetConversationsResponse.fromPartial({conversations:e})}async getPublicKeyBundle(){return this.v1Keys.getPublicKeyBundle()}async getPrivateKeyBundle(){return this.v1Keys}async getAccountAddress(){return this.accountAddress||(this.accountAddress=await this.v2Keys.getPublicKeyBundle().walletSignatureAddress()),this.accountAddress}async getRefreshJob({jobType:e}){if(e===i.JobType.JOB_TYPE_UNSPECIFIED)throw new Ke(Jt.ERROR_CODE_INVALID_INPUT,"invalid job type");const t=await this.getLastRunTime(e);return i.GetRefreshJobResponse.fromPartial({lastRunNs:t||l.fromNumber(0)})}async setRefreshJob({jobType:e,lastRunNs:t}){const s=await this.buildJobStorageKey(e);return await this.jobStatePersistence.setItem(s,Uint8Array.from(t.toBytes())),{}}topicDataToV1ConversationReference(e){return{peerAddress:e.peerAddress,createdNs:e.createdNs,topic:Se(e.peerAddress,this.walletAddress),context:void 0,consentProofPayload:void 0}}buildJobStorageKey(e){return`refreshJob/${e.toString()}`}async getLastRunTime(e){const t=await this.jobStatePersistence.getItem(this.buildJobStorageKey(e));if(t&&t.length)return l.fromBytes([...t])}lookupTopic(e){return this.v2Store.lookup(e)}async getV2ConversationHmacKeys(e){const t=Math.floor(Date.now()/1e3/60/60/24/30),s={};let n=this.v2Store.topics;return e?.topics&&(n=n.filter((t=>void 0!==t.invitation&&e.topics.includes(t.invitation.topic)))),await Promise.all(n.map((async e=>{if(e.invitation?.topic){const n=Ft(e.invitation),r=await Promise.all([t-1,t,t+1].map((async e=>{const t=`${e}-${await this.getAccountAddress()}`,s=await q(n,(new TextEncoder).encode(t));return{thirtyDayPeriodsSinceEpoch:e,hmacKey:await H(s)}})));s[e.invitation.topic]={values:r}}}))),{hmacKeys:s}}}class Wt{constructor(e){this.apiClient=e}async getItem(e){for await(const t of this.apiClient.queryIterator({contentTopic:this.buildTopic(e)},{pageSize:1,direction:d.SortDirection.SORT_DIRECTION_DESCENDING}))if(t.message)try{return Uint8Array.from(t.message)}catch(e){console.log(e)}return null}async setItem(e,t){const s=Uint8Array.from(t);await this.apiClient.publish([{contentTopic:this.buildTopic(e),message:s}])}setAuthenticator(e){this.apiClient.setAuthenticator(e)}buildTopic(e){return Re(e)}}class Qt{constructor({eciesBytes:t,signature:s}){if(!t||!t.length)throw new Error("eciesBytes is empty");if(!s)throw new Error("signature is undefined");this.eciesBytes=t,this.signature=new Z(s),this.ciphertext=e.SignedEciesCiphertext_Ecies.decode(t)}toBytes(){return e.SignedEciesCiphertext.encode(this).finish()}async verify(e){return e.verify(this.signature,await M(this.eciesBytes))}static fromBytes(t){const s=e.SignedEciesCiphertext.decode(t);return new Qt(s)}static async create(t,s){(e=>{if(16!==e.iv.length)throw new Error("Invalid iv length");if(65!==e.ephemeralPublicKey.length)throw new Error("Invalid ephemPublicKey length");if(e.ciphertext.length<1||e.ciphertext.length%16!=0)throw new Error("Invalid ciphertext length");if(32!==e.mac.length)throw new Error("Invalid mac length")})(t);const n=e.SignedEciesCiphertext_Ecies.encode(t).finish(),r=await s.sign(await M(n));return new Qt({eciesBytes:n,signature:r})}}class Zt{constructor(e,t){this.persistence=e,this.privateKey=t,this.privateKeyBytes=Buffer.from(t.secp256k1.bytes),this.publicKey=It(this.privateKeyBytes)}async getItem(e){const t=await this.persistence.getItem(e);return t?this.decrypt(t):null}async setItem(e,t){const s=await this.encrypt(t);await this.persistence.setItem(e,s)}async encrypt(e){const t=await async function(e,t,s){s=s||{};const n=s?.iv||Tt(16);let r=s?.ephemPrivateKey||Tt(32);for(;!At(r);){if(s?.ephemPrivateKey)throw new Error("ephemPrivateKey is not valid");r=Tt(32)}const i=It(r),o=await kt(await Rt(r,e)),a=o.slice(0,32),c=o.slice(32),d=await Pt(n,a,t),h=Buffer.concat([n,i,d]);return{iv:n,ephemeralPublicKey:i,ciphertext:d,mac:await Bt(c,h)}}(this.publicKey,Buffer.from(e));return this.serializeEcies(t)}async decrypt(e){const t=await this.deserializeEcies(e),s=await Nt(this.privateKeyBytes,t);return Uint8Array.from(s)}async serializeEcies(e){return(await Qt.create(e,this.privateKey)).toBytes()}async deserializeEcies(e){const t=Qt.fromBytes(e);if(!await t.verify(this.privateKey.publicKey))throw new Error("signature validation failed");const s=t.ciphertext;return{ciphertext:Buffer.from(s.ciphertext),mac:Buffer.from(s.mac),iv:Buffer.from(s.iv),ephemeralPublicKey:Buffer.from(s.ephemeralPublicKey)}}}class es{constructor(e,t){this.prefix=e,this.persistence=t}getItem(e){return this.persistence.getItem(this.buildKey(e))}setItem(e,t){return this.persistence.setItem(this.buildKey(e),t)}buildKey(e){return this.prefix+e}}const ts=async(e,t)=>{if(!e.persistConversations)return wt.create();const s=await t.identityKey.publicKey.walletSignatureAddress(),n=`xmtp/${e.env}/${s}/`;const r=e.basePersistence,i=!e.disablePersistenceEncryption;return new es(n,i?new Zt(r,t.identityKey):r)},ss="key_bundle";class ns{constructor(e,t,s){this.signer=e,this.persistence=t,this.preEnableIdentityCallback=s}async getStorageAddress(e){let t=await this.signer.getAddress();return t=g(t),`${t}/${e}`}async loadPrivateKeyBundle(){const e=await this.persistence.getItem(await this.getStorageAddress(ss));if(!e)return null;const[t,s]=await this.fromEncryptedBytes(this.signer,Uint8Array.from(e));return s&&await this.storePrivateKeyBundle(t),t}async storePrivateKeyBundle(e){const t=await this.getStorageAddress(ss),s=await this.toEncryptedBytes(e,this.signer);"function"==typeof this.persistence.setAuthenticator&&this.persistence.setAuthenticator(new mt(e.identityKey)),await this.persistence.setItem(t,s)}async toEncryptedBytes(e,s){const n=e.encode(),r=R.getRandomValues(new Uint8Array(32)),i=is(r),o=await s.getAddress();this.preEnableIdentityCallback&&await this.preEnableIdentityCallback();const a=await s.signMessage(i);if(!K({address:o,message:i,signature:a}))throw new Error("invalid signature");const c=b(a),d=await _(n,c);return t.EncryptedPrivateKeyBundle.encode({v1:{walletPreKey:r,ciphertext:d}}).finish()}async fromEncryptedBytes(e,s){const[n,r]=function(e){try{const s=t.EncryptedPrivateKeyBundle.decode(e);if(s.v1)return[s.v1,!1]}catch(s){return[t.EncryptedPrivateKeyBundleV1.decode(e),!0]}throw new Error("unrecognized encrypted private key bundle version")}(s);if(!n.walletPreKey)throw new Error("missing wallet pre-key");if(!n.ciphertext?.aes256GcmHkdfSha256)throw new Error("missing bundle ciphertext");this.preEnableIdentityCallback&&await this.preEnableIdentityCallback();const i=b(await e.signMessage(is(n.walletPreKey)));try{const e=new I(n.ciphertext),t=await x(e,i),[s,o]=rs(t);return[s,r||o]}catch(e){if(65!==i.length)throw new Error("Expected 65 bytes before trying a different recovery byte");const t=i[i.length-1];let s=i.slice(0,i.length-1);s=t<27?new Uint8Array([...s,t+27]):new Uint8Array([...s,t-27]);const o=new I(n.ciphertext),a=await x(o,s),[c,d]=rs(a);return[c,r||d]}}}function rs(e){try{const t=je(e);if(t instanceof Ge)throw new Error("V2 bundles not supported yet");return[t,!1]}catch(s){const n=t.PrivateKeyBundleV1.decode(e);return[new $e(n),!0]}}function is(e){return`XMTP : Enable Identity\n${G(e)}\n\nFor more info: https://xmtp.org/signatures/`}class os{async newKeystore(e,t,s){if(!s)throw new ft("Wallet required to generate new keys");e.preCreateIdentityCallback&&await e.preCreateIdentityCallback();const n=await $e.generate(s),r=new ns(s,new Wt(t),e.preEnableIdentityCallback);return await r.storePrivateKeyBundle(n),Yt.create(n,await ts(e,n))}}class as{async newKeystore(e,t,s){if(!s)throw new ft("No wallet provided");const n=new ns(s,new Wt(t),e.preEnableIdentityCallback),r=await n.loadPrivateKeyBundle();if(!r)throw new ft("No keys found");return Yt.create(r,await ts(e,r))}}function cs(){return window.ethereum}function ds(e){const[t,s,...n]=e.split(".");return{major:Number(t),minor:Number(s),patch:n.join(".")}}function hs(e,t){if(!e||!t)return!1;const s=ds(e),n=ds(t);return s.major!==n.major?s.major>n.major:s.minor!==n.minor?s.minor>n.minor:!(!s.patch||!n.patch)&&function(e,t){const[s,n]=e.split("-"),[r,i]=t.split("-");if(Number(s)!==Number(r))return Number(s)>Number(r);if(!n||!i)return!1;const[o,a]=n.split("."),[c,d]=i.split(".");if(o!==c)return!0;return Number(a)>Number(d)}(s.patch,n.patch)}const{GetKeystoreStatusResponse_KeystoreStatus:ys,InitKeystoreRequest:us,InitKeystoreResponse:ps,GetKeystoreStatusRequest:ls,GetKeystoreStatusResponse:ws}=i;async function fs(e,t,s,n,r){let i=null;if(t.req){const e=(0,t.req.encode)(s).finish();i=fe(e,0,e.length)}const o=await async function(e,t,s,n){const r={meta:s};"string"==typeof t&&(r.req=t);const i=await(cs()?.request({method:"wallet_invokeSnap",params:{snapId:n,request:{method:e,params:r}}}));if(!i||"object"!=typeof i)throw new Error("No response value");return i.res}(e,i,n,r);if(Array.isArray(o))throw new Error("Unexpected array response");return t.res.decode(we(o))}async function ms(){const e=cs();if(e?.isMetaMask)try{return await e.request({method:"wallet_getSnaps"}),!0}catch{}if(void 0!==e?.detected&&Array.isArray(e.detected))for(const t of e.detected)try{return await t.request({method:"wallet_getSnaps"}),e?.setProvider?.(t),!0}catch{}if(void 0!==e?.providers&&Array.isArray(e.providers))for(const t of e.providers)try{return await t.request({method:"wallet_getSnaps"}),window.ethereum=t,!0}catch{}return!1}async function gs(e,t){try{const s=await async function(){return await(cs()?.request({method:"wallet_getSnaps"}))}();return s?Object.values(s).find((s=>{return s&&s.id===e&&(!t||(n=s.version,r=t,!n||!r||ds(n).major===ds(r).major));var n,r})):void 0}catch(e){return void console.warn("Failed to obtain installed snap",e)}}const vs={req:ls,res:ws};const bs={req:us,res:ps};const Es={decryptV1:{req:i.DecryptV1Request,res:i.DecryptResponse},decryptV2:{req:i.DecryptV2Request,res:i.DecryptResponse},encryptV1:{req:i.EncryptV1Request,res:i.EncryptResponse},encryptV2:{req:i.EncryptV2Request,res:i.EncryptResponse},saveInvites:{req:i.SaveInvitesRequest,res:i.SaveInvitesResponse},createInvite:{req:i.CreateInviteRequest,res:i.CreateInviteResponse},createAuthToken:{req:i.CreateAuthTokenRequest,res:c.Token},signDigest:{req:i.SignDigestRequest,res:s.Signature},getPublicKeyBundle:{req:null,res:n.PublicKeyBundle},getPrivateKeyBundle:{req:null,res:t.PrivateKeyBundleV1},saveV1Conversations:{req:i.SaveV1ConversationsRequest,res:i.SaveV1ConversationsResponse},getV1Conversations:{req:null,res:i.GetConversationsResponse},getV2Conversations:{req:null,res:i.GetConversationsResponse},getRefreshJob:{req:i.GetRefreshJobRequest,res:i.GetRefreshJobResponse},setRefreshJob:{req:i.SetRefeshJobRequest,res:i.SetRefreshJobResponse},selfEncrypt:{req:i.SelfEncryptRequest,res:i.SelfEncryptResponse},selfDecrypt:{req:i.SelfDecryptRequest,res:i.DecryptResponse},getPrivatePreferencesTopicIdentifier:{req:null,res:i.GetPrivatePreferencesTopicIdentifierResponse},getV2ConversationHmacKeys:{req:i.GetConversationHmacKeysRequest,res:i.GetConversationHmacKeysResponse}},Ks={...Es,getKeystoreStatus:{req:i.GetKeystoreStatusRequest,res:i.GetKeystoreStatusResponse},initKeystore:{req:i.InitKeystoreRequest,res:i.InitKeystoreResponse}};const{GetKeystoreStatusResponse_KeystoreStatus:As}=i;class Ts{constructor(e="local:http://localhost:8080",t){this.snapId=e,this.snapVersion=t}async newKeystore(e,t,s){if(!s)throw new ft("No wallet provided");if(!await ms())throw new ft("MetaMask with Snaps not detected");const n=await s.getAddress(),r=e.env,i=await gs(this.snapId,this.snapVersion);if(i&&!hs(this.snapVersion,i.version)||await async function(e,t={}){await(cs()?.request({method:"wallet_requestSnaps",params:{[e]:t}}))}(this.snapId,this.snapVersion?{version:this.snapVersion}:{}),!await async function(e,t,s){const n=await async function(e,t){const s=await fs("getKeystoreStatus",vs,{walletAddress:e.walletAddress},e,t);if([ys.KEYSTORE_STATUS_UNSPECIFIED,ys.UNRECOGNIZED].includes(s.status))throw new Error("No status specified in response");return s.status}({walletAddress:e,env:t},s);if(n===As.KEYSTORE_STATUS_INITIALIZED)return!0;return!1}(n,r,this.snapId)){const n=await async function(e,t,s){if(e.privateKeyOverride){const t=je(e.privateKeyOverride);if(!(t instanceof $e))throw new Error("Unsupported private key bundle version");return t}if(!s)throw new Error("No privateKeyOverride or wallet");return async function(e,t,s){const n=new as;try{const r=await n.newKeystore(e,t,s);return new $e(await r.getPrivateKeyBundle())}catch(n){if(n instanceof ft)return async function(e,t,s){const n=new os,r=await n.newKeystore(e,t,s);return new $e(await r.getPrivateKeyBundle())}(e,t,s);throw n}}(e,t,s)}(e,t,s);await async function(e,t,s){const n=e.identityKey.publicKey.walletSignatureAddress(),r=await fs("initKeystore",bs,{v1:e},{walletAddress:n,env:t},s);if(r.error)throw new Ke(r.error.code,r.error.message)}(n,r,this.snapId)}return function(e,t,s){const n={},r={walletAddress:e,env:t};for(const[e,t]of Object.entries(Ks))n[e]=async n=>t.req?fs(e,t,n,r,s):fs(e,t,void 0,r,s);return{...n,getAccountAddress:async()=>e}}(n,r,this.snapId)}}class ks{async newKeystore(e){const{privateKeyOverride:t}=e;if(!t)throw new ft("No private key override provided");const s=je(t);if(s instanceof Ge)throw new Error("V2 private key bundle found. Only V1 supported");return Yt.create(s,await ts(e,s))}}function Ss(e){if(!e)return null;if(function(e){return"type"in e&&("walletClient"===e.type||"base"===e.type)}(e))return function(e){const{account:t}=e;if(!t||!t.address)throw new Error("WalletClient is not configured");return{getAddress:async()=>t.address,signMessage:async s=>e.signMessage({message:"string"==typeof s?s:{raw:s},account:t})}}(e);if("function"!=typeof e.getAddress)throw new Error("Unknown wallet type");return e}function Ps(e){if(e===a.Compression.COMPRESSION_GZIP)return"gzip";if(e===a.Compression.COMPRESSION_DEFLATE)return"deflate";throw new Error("unrecognized compression algorithm")}function Cs(e,t=1024){let s=0;return new ReadableStream({pull(n){if(s>=e.length)return n.close();let r=s+t;r=r<=e.length?r:e.length,n.enqueue(e.subarray(s,r)),s=r}})}function Bs(e,t){let s=0;return new WritableStream({write(n){const r=s+n.length;if(r>t)throw new Error("maximum output size exceeded");for(;e.bytes.length<r;)e.bytes=Is(e.bytes,t);e.bytes.set(n,s),s=r},close(){s<e.bytes.length&&(e.bytes=e.bytes.subarray(0,s))}})}function Is(e,t){let s=2*e.length;s>t&&(s=t);const n=new Uint8Array(s);return n.set(e),n}function Rs(e){let t;try{t=y.ContactBundle.decode(e)}catch(s){const r=n.PublicKeyBundle.decode(e);t={v1:{keyBundle:new ae(r)},v2:void 0}}if(t.v1?.keyBundle)return new ae(t.v1.keyBundle);if(t.v2?.keyBundle)return new oe(t.v2.keyBundle);throw new Error("unknown or invalid contact bundle")}function Ns(e){return e instanceof ae?y.ContactBundle.encode({v1:{keyBundle:e},v2:void 0}).finish():y.ContactBundle.encode({v1:void 0,v2:{keyBundle:e}}).finish()}class Ds{constructor(e,t,s){this.value=e,this.entryType=t,this.permissionType=s}get key(){return`${this.entryType}-${this.value}`}static fromAddress(e,t="unknown"){return new Ds(e,"address",t)}}class Ms{constructor(e){this.entries=new Map,this.client=e}allow(e){const t=Ds.fromAddress(e,"allowed");return this.entries.set(t.key,"allowed"),t}deny(e){const t=Ds.fromAddress(e,"denied");return this.entries.set(t.key,"denied"),t}state(e){const t=Ds.fromAddress(e);return this.entries.get(t.key)??"unknown"}async getIdentifier(){if(!this._identifier){const{identifier:e}=await this.client.keystore.getPrivatePreferencesTopicIdentifier();this._identifier=e}return this._identifier}async decodeMessages(e){const{responses:t}=await this.client.keystore.selfDecrypt({requests:e.map((e=>({payload:e})))});return t.reduce(((e,t)=>t.result?.decrypted?e.concat(u.PrivatePreferencesAction.decode(t.result.decrypted)):e),[])}processActions(e,t){const s=[];return e.forEach((e=>{e.allowAddress?.walletAddresses.forEach((e=>{s.push(this.allow(e))})),e.denyAddress?.walletAddresses.forEach((e=>{s.push(this.deny(e))}))})),t&&(this.lastEntryTimestamp=Ee(t)),s}async stream(e){const t=await this.getIdentifier(),s=Ne(t);return le.create(this.client,[s],(async e=>{if(!e.message)return;const t=await this.decodeMessages([e.message]);return this.processActions(t,e.timestampNs),t[0]}),void 0,e)}reset(){this.entries.clear()}async load(e){const t=await this.getIdentifier(),s=Ne(t);let n;const r=await this.client.listEnvelopes(s,(async({message:e,timestampNs:t})=>(t&&(n=t),e)),{startTime:e}),i=await this.decodeMessages(r);return this.processActions(i,n)}async publish(e){const t=await this.getIdentifier(),s=e.reduce(((e,t)=>{if("address"===t.entryType){const s={allowAddress:"allowed"===t.permissionType?{walletAddresses:[t.value]}:void 0,denyAddress:"denied"===t.permissionType?{walletAddresses:[t.value]}:void 0,allowGroup:void 0,denyGroup:void 0};return e.concat(u.PrivatePreferencesAction.encode(s).finish())}return e}),[]),{responses:n}=await this.client.keystore.selfEncrypt({requests:s.map((e=>({payload:e})))}),r=n.reduce(((e,t)=>t.result?.encrypted?e.concat(t.result?.encrypted):e),[]),i=Ne(t),o=new Date,a=r.map((e=>({contentTopic:i,message:e,timestamp:o})));await this.client.publishEnvelopes(a),e.forEach((e=>{this.entries.set(e.key,e.permissionType)}))}}class _s{constructor(e){this.addresses=new Set,this.consentList=new Ms(e),this.client=e,this.jobRunner=new ht("user-preferences",e.keystore)}validateConsentSignature({signature:e,timestamp:t},s){const n=Number(t);if(!e||!n)return!1;if(n>Date.now())return!1;if(n<Date.now()-2592e6)return!1;const r=j(e),i=B(s,n),o=Q(b(E(i)),r);return o?.getEthereumAddress()===this.client.address}async loadConsentList(e){return this.jobRunner.run((async t=>{const s=await this.consentList.load(e??t);try{const e=(await this.client.conversations.list()).reduce(((e,t)=>t.consentProof&&"unknown"===this.consentState(t.peerAddress)&&this.validateConsentSignature(t.consentProof,t.peerAddress)?e.concat(t.peerAddress):e),[]);e.length&&await this.client.contacts.allow(e)}catch(e){console.log(e)}return s}))}async refreshConsentList(){return this.consentList.reset(),await this.jobRunner.resetLastRunTime(),this.loadConsentList()}async streamConsentList(e){return this.consentList.stream(e)}get lastConsentListEntryTimestamp(){return this.consentList.lastEntryTimestamp}setConsentListEntries(e){e.length&&(this.consentList.reset(),e.forEach((e=>{"allowed"===e.permissionType&&this.consentList.allow(e.value),"denied"===e.permissionType&&this.consentList.deny(e.value)})))}isAllowed(e){return"allowed"===this.consentList.state(e)}isDenied(e){return"denied"===this.consentList.state(e)}consentState(e){return this.consentList.state(e)}async allow(e){await this.consentList.publish(e.map((e=>Ds.fromAddress(e,"allowed"))))}async deny(e){await this.consentList.publish(e.map((e=>Ds.fromAddress(e,"denied"))))}}var xs;!function(e){e[e.none=0]="none",e[e.xmtpTopicStore=1]="xmtpTopicStore"}(xs||(xs={}));const Vs=xs.none;class Us{static createConfiguration(){return{type:Vs,version:0}}constructor(e){this.configuration=e}get backupType(){return Vs}}const qs=xs.xmtpTopicStore;class Os{static createConfiguration(e){return{type:qs,version:0,topic:"history-v0:"+e}}constructor(e){this.configuration=e}get backupType(){return qs}}async function Ls(e,t){const s=await async function(e,t){let s;switch((await t()).type){case xs.none:s=Us.createConfiguration();break;case xs.xmtpTopicStore:s=Os.createConfiguration(e)}return s}(e,t);switch(s.type){case xs.none:return new Us(s);case xs.xmtpTopicStore:return new Os(s)}}const{Compression:Hs}=a,Fs=104857600;class Gs{constructor(e,t,s,n){this.knownPublicKeyBundles=new Map,this.keystore=n,this.publicKeyBundle=e,this.address=e.walletSignatureAddress(),this._conversations=new ut(this),this._codecs=new Map,this._maxContentSize=Fs,this.apiClient=t,this._backupClient=s,this.contacts=new _s(this)}get conversations(){return this._conversations}get backupType(){return this._backupClient.backupType}get signedPublicKeyBundle(){return oe.fromLegacyBundle(this.publicKeyBundle)}static async create(e,t){const s=Ss(e),n=function(e){const t={privateKeyOverride:void 0,env:"dev",apiUrl:void 0,codecs:[new ue],maxContentSize:Fs,persistConversations:!0,skipContactPublishing:!1,useSnaps:!1,basePersistence:"undefined"!=typeof window&&void 0!==window.document?pt.create():wt.create(),disablePersistenceEncryption:!1,keystoreProviders:Js(),apiClientFactory:$s};return e?.codecs&&(e.codecs=t.codecs.concat(e.codecs)),e?.useSnaps&&(e.keystoreProviders=[new Ts("npm:@xmtp/snap","1.3.6"),...t.keystoreProviders]),{...t,...e}}(t),r=n.apiClientFactory(n),i=await async function(e,t,s){for(const n of e.keystoreProviders)try{return await n.newKeystore(e,t,s??void 0)}catch(e){if(e instanceof ft)continue;throw e}throw new Error("No keystore providers available")}(n,r,s),o=new ae(await i.getPublicKeyBundle()),a=o.walletSignatureAddress();r.setAuthenticator(new ze(i));const c=await Gs.setupBackupClient(a,n.env),d=new Gs(o,r,c,i);return await d.init(n),d}static async getKeys(e,t){const s=await Gs.create(Ss(e),t),n=await s.keystore.getPrivateKeyBundle();return new $e(n).encode()}static isSnapsReady(){return ms()}static async setupBackupClient(e,t){return Ls(e,(async()=>Promise.resolve({type:"local"===t?xs.xmtpTopicStore:xs.none})))}async init(e){e.codecs.forEach((e=>{this.registerCodec(e)})),this._maxContentSize=e.maxContentSize,e.skipContactPublishing||await this.ensureUserContactPublished(e.publishLegacyContact)}async close(){}async ensureUserContactPublished(e=!1){const t=await js(this.apiClient,this.address);t&&t instanceof oe&&this.signedPublicKeyBundle.equals(t)||(await this.publishUserContact(!0),e||await this.publishUserContact(e))}async publishUserContact(e=!1){const t=e?this.publicKeyBundle:this.signedPublicKeyBundle;await this.publishEnvelopes([{contentTopic:Ce(this.address),message:Ns(t)}])}async getUserContact(e){e=g(e);const t=this.knownPublicKeyBundles.get(e);if(t)return t;const s=await js(this.apiClient,e);return s&&this.knownPublicKeyBundles.set(e,s),s}async getUserContacts(e){const t=e.map((e=>g(e))),s=new Map,n=[];for(const e of t){const t=this.knownPublicKeyBundles.get(e);t?s.set(e,t):(s.set(e,void 0),n.push(e))}const r=await Xs(this.apiClient,n);for(let e=0;e<r.length;e++){const t=n[e],i=r[e];s.set(t,i),i&&this.knownPublicKeyBundles.set(t,i)}return t.map((e=>s.get(e)))}forgetContact(e){e=g(e),this.knownPublicKeyBundles.delete(e)}async canMessage(e){try{if(Array.isArray(e)){return(await this.getUserContacts(e)).map((e=>!!e))}return void 0!==await this.getUserContact(e)}catch(e){return!1}}static async canMessage(e,t){const s=t?.apiUrl||nt[t?.env||"dev"],n=new dt(s,{appVersion:t?.appVersion});if(Array.isArray(e)){const t=e.map((e=>g(e)));return(await Xs(n,t)).map((e=>!!e))}try{e=g(e)}catch(e){return!1}return void 0!==await js(n,e)}validateEnvelope(e){const t=e.message;if(!e.contentTopic)throw new Error("Missing content topic");if(!t||!t.length)throw new Error("Cannot publish empty message")}async publishEnvelopes(e){for(const t of e)this.validateEnvelope(t);await this.apiClient.publish(e)}registerCodec(e){const t=e.contentType,s=`${t.authorityId}/${t.typeId}`;return this._codecs.set(s,e),this}codecFor(e){const t=`${e.authorityId}/${e.typeId}`,s=this._codecs.get(t);if(s&&!(e.versionMajor>s.contentType.versionMajor))return s}async encodeContent(e,t){const s=t?.contentType||he,n=this.codecFor(s);if(!n)throw new Error("unknown content type "+s);const r=n.encode(e,this),i=n.fallback(e);return i&&(r.fallback=i),"number"==typeof t?.compression&&r.content.length>=10&&(r.compression=t.compression),await async function(e){if(void 0===e.compression)return;const t={bytes:new Uint8Array(e.content.length/10)};await Cs(e.content).pipeThrough(new CompressionStream(Ps(e.compression))).pipeTo(Bs(t,e.content.length+1e3)),e.content=t.bytes}(r),{payload:a.EncodedContent.encode(r).finish(),shouldPush:n.shouldPush(e)}}async decodeContent(e){const t=a.EncodedContent.decode(e);if(!t.type)throw new Error("missing content type");let s;const n=new ce(t.type);let r;await async function(e,t){if(void 0===e.compression)return;const s={bytes:new Uint8Array(e.content.length)};await Cs(e.content).pipeThrough(new DecompressionStream(Ps(e.compression))).pipeTo(Bs(s,t)),e.content=s.bytes}(t,1e3);const i=this.codecFor(n);return i?s=i.decode(t,this):r=new Error("unknown content type "+n),{content:s,contentType:n,error:r,contentFallback:t.fallback}}listInvitations(e){return this.listEnvelopes(Ie(this.address),(async e=>e),e)}async listEnvelopes(e,t,s){s||(s={});const{startTime:n,endTime:r,limit:i}=s,o=await this.apiClient.query({contentTopic:e,startTime:n,endTime:r},{direction:s.direction||d.SortDirection.SORT_DIRECTION_ASCENDING,limit:i}),a=[];for(const e of o)if(e.message)try{const s=await t(e);a.push(s)}catch(e){console.warn("Error in listEnvelopes mapper",e)}return a}listEnvelopesPaginated(e,t,s){return Ze(this.apiClient.queryIteratePages({contentTopic:e,startTime:s?.startTime,endTime:s?.endTime},{direction:s?.direction,pageSize:s?.pageSize||100}),t)}}function $s(e){const t=e.apiUrl||nt[e.env];return new dt(t,{appVersion:e.appVersion})}async function js(e,t){const s=e.queryIterator({contentTopic:Ce(t)},{pageSize:5,direction:st.SORT_DIRECTION_DESCENDING});for await(const e of s){if(!e.message)continue;const s=Rs(e.message);let n;try{n=await(s?.walletSignatureAddress())}catch(e){n=void 0}if(n?.toLowerCase()===t.toLowerCase())return s}}async function Xs(e,t){const s=t.map(Ce),n=await e.batchQuery(s.map((e=>({contentTopic:e,pageSize:5,direction:st.SORT_DIRECTION_DESCENDING}))));return Promise.all(t.map((async(e,t)=>{const s=n[t];if(s)for(const t of s)if(t.message)try{const s=Rs(t.message),n=await(s?.walletSignatureAddress());if(e.toLowerCase()===n.toLowerCase())return s;console.info("Received contact bundle with incorrect address")}catch(e){console.info("Invalid contact bundle",e)}})))}function Js(){return[new ks,new as,new os]}const zs=new ce({authorityId:"xmtp.org",typeId:"composite",versionMajor:1,versionMinor:0});class Ys{get contentType(){return zs}encode(e,t){const s=this.toProto(e,t);let n;n=s.composite?s.composite:{parts:[s]};const r=p.Composite.encode(n).finish();return{type:zs,parameters:{},content:r}}decode(e,t){return this.fromProto({composite:p.Composite.decode(e.content),part:void 0},t)}toProto(e,t){if("type"in e){const s=t.codecFor(e.type);if(!s)throw new Error(`missing codec for part type ${e.type}`);return{part:s.encode(e.content,t),composite:void 0}}const s=new Array;for(const n of e.parts)s.push(this.toProto(n,t));return{composite:{parts:s},part:void 0}}fromProto(e,t){if(e.part){if(!e.part.type)throw new Error("missing part content type");const s=new ce(e.part.type),n=t.codecFor(s);if(!n)throw new Error(`missing codec for part type ${s}`);return{type:s,content:n.decode(e.part,t)}}if(!e.composite)throw new Error("invalid composite");const s=new Array;for(const n of e.composite.parts)s.push(this.fromProto(n,t));return{parts:s}}fallback(e){}shouldPush(){return!1}}export{nt as ApiUrls,et as AuthCache,pt as BrowserStoragePersistence,I as Ciphertext,Gs as Client,Ys as CompositeCodec,Hs as Compression,Ds as ConsentListEntry,zs as ContentTypeComposite,de as ContentTypeFallback,ce as ContentTypeId,he as ContentTypeText,Me as ConversationV1,_e as ConversationV2,ut as Conversations,Oe as DecodedMessage,Zt as EncryptedPersistence,dt as HttpApiClient,Yt as InMemoryKeystore,wt as InMemoryPersistence,_t as InvitationV1,os as KeyGeneratorKeystoreProvider,mt as LocalAuthenticator,Ue as MessageV1,qe as MessageV2,as as NetworkKeystoreProvider,es as PrefixedPersistence,z as PrivateKey,$e as PrivateKeyBundleV1,Ge as PrivateKeyBundleV2,ie as PublicKey,ae as PublicKeyBundle,Ut as SealedInvitation,Z as Signature,re as SignedPublicKey,oe as SignedPublicKeyBundle,Ts as SnapProvider,st as SortDirection,ks as StaticKeystoreProvider,le as Stream,ue as TextCodec,ke as buildContentTopic,Se as buildDirectMessageTopic,Pe as buildDirectMessageTopicV2,Ce as buildUserContactTopic,Be as buildUserIntroTopic,Ie as buildUserInviteTopic,Re as buildUserPrivateStoreTopic,ge as dateToNs,Rs as decodeContactBundle,He as decodeContent,x as decrypt,Js as defaultKeystoreProviders,_ as encrypt,H as exportHmacKey,Ee as fromNanoString,O as generateHmacSignature,q as hkdfHmacKey,F as importHmacKey,Es as keystoreApiDefs,Ze as mapPaginatedStream,ve as nsToDate,Qe as retry,Ks as snapKeystoreApiDefs,be as toNanoString,L as verifyHmacSignature};
//# sourceMappingURL=index.js.map
