'use strict';

var node_path = require('node:path');
var process = require('node:process');
var contentTypeText = require('@xmtp/content-type-text');
var nodeBindings = require('@xmtp/node-bindings');
var contentTypePrimitives = require('@xmtp/content-type-primitives');
var proto = require('@xmtp/proto');

const ContentTypeGroupUpdated = new contentTypePrimitives.ContentTypeId({
    authorityId: "xmtp.org",
    typeId: "group_updated",
    versionMajor: 1,
    versionMinor: 0,
});
class GroupUpdatedCodec {
    get contentType() {
        return ContentTypeGroupUpdated;
    }
    encode(content) {
        return {
            type: this.contentType,
            parameters: {},
            content: proto.mlsTranscriptMessages.GroupUpdated.encode(content).finish(),
        };
    }
    decode(content) {
        return proto.mlsTranscriptMessages.GroupUpdated.decode(content.content);
    }
    fallback() {
        return undefined;
    }
    shouldPush() {
        return false;
    }
}

class AsyncStream {
    #done = false;
    #resolveNext;
    #queue;
    stopCallback = undefined;
    constructor() {
        this.#queue = [];
        this.#resolveNext = null;
        this.#done = false;
    }
    get isDone() {
        return this.#done;
    }
    callback = (err, value) => {
        if (err) {
            console.error("stream error", err);
            this.stop();
            return;
        }
        if (this.#done) {
            return;
        }
        if (this.#resolveNext) {
            this.#resolveNext({ value, done: false });
            this.#resolveNext = null;
        }
        else {
            this.#queue.push(value);
        }
    };
    stop = () => {
        this.#done = true;
        if (this.#resolveNext) {
            this.#resolveNext({ value: undefined, done: true });
        }
        this.stopCallback?.();
    };
    next = () => {
        if (this.#queue.length > 0) {
            return Promise.resolve({ value: this.#queue.shift(), done: false });
        }
        else if (this.#done) {
            return Promise.resolve({ value: undefined, done: true });
        }
        else {
            return new Promise((resolve) => {
                this.#resolveNext = resolve;
            });
        }
    };
    [Symbol.asyncIterator]() {
        return this;
    }
}

function nsToDate(ns) {
    return new Date(ns / 1_000_000);
}

class DecodedMessage {
    #client;
    content;
    contentType;
    conversationId;
    deliveryStatus;
    fallback;
    compression;
    id;
    kind;
    parameters;
    senderInboxId;
    sentAt;
    sentAtNs;
    constructor(client, message) {
        this.#client = client;
        this.id = message.id;
        this.sentAtNs = message.sentAtNs;
        this.sentAt = nsToDate(message.sentAtNs);
        this.conversationId = message.convoId;
        this.senderInboxId = message.senderInboxId;
        switch (message.kind) {
            case 0 /* NapiGroupMessageKind.Application */:
                this.kind = "application";
                break;
            case 1 /* NapiGroupMessageKind.MembershipChange */:
                this.kind = "membership_change";
                break;
            // no default
        }
        switch (message.deliveryStatus) {
            case 0 /* NapiDeliveryStatus.Unpublished */:
                this.deliveryStatus = "unpublished";
                break;
            case 1 /* NapiDeliveryStatus.Published */:
                this.deliveryStatus = "published";
                break;
            case 2 /* NapiDeliveryStatus.Failed */:
                this.deliveryStatus = "failed";
                break;
            // no default
        }
        this.contentType = new contentTypePrimitives.ContentTypeId(message.content.type);
        this.parameters = message.content.parameters;
        this.fallback = message.content.fallback;
        this.compression = message.content.compression;
        this.content = this.#client.decodeContent(message, this.contentType);
    }
}

class Conversation {
    #client;
    #group;
    constructor(client, group) {
        this.#client = client;
        this.#group = group;
    }
    get id() {
        return this.#group.id();
    }
    get name() {
        return this.#group.groupName();
    }
    async updateName(name) {
        return this.#group.updateGroupName(name);
    }
    get imageUrl() {
        return this.#group.groupImageUrlSquare();
    }
    async updateImageUrl(imageUrl) {
        return this.#group.updateGroupImageUrlSquare(imageUrl);
    }
    get description() {
        return this.#group.groupDescription();
    }
    async updateDescription(description) {
        return this.#group.updateGroupDescription(description);
    }
    get pinnedFrameUrl() {
        return this.#group.groupPinnedFrameUrl();
    }
    async updatePinnedFrameUrl(pinnedFrameUrl) {
        return this.#group.updateGroupPinnedFrameUrl(pinnedFrameUrl);
    }
    get isActive() {
        return this.#group.isActive();
    }
    get addedByInboxId() {
        return this.#group.addedByInboxId();
    }
    get createdAtNs() {
        return this.#group.createdAtNs();
    }
    get createdAt() {
        return nsToDate(this.createdAtNs);
    }
    get metadata() {
        const metadata = this.#group.groupMetadata();
        return {
            creatorInboxId: metadata.creatorInboxId(),
            conversationType: metadata.conversationType(),
        };
    }
    async members() {
        return this.#group.listMembers();
    }
    get admins() {
        return this.#group.adminList();
    }
    get superAdmins() {
        return this.#group.superAdminList();
    }
    get permissions() {
        return {
            policyType: this.#group.groupPermissions().policyType(),
            policySet: this.#group.groupPermissions().policySet(),
        };
    }
    isAdmin(inboxId) {
        return this.#group.isAdmin(inboxId);
    }
    isSuperAdmin(inboxId) {
        return this.#group.isSuperAdmin(inboxId);
    }
    async sync() {
        return this.#group.sync();
    }
    stream(callback) {
        const asyncStream = new AsyncStream();
        const stream = this.#group.stream((err, message) => {
            const decodedMessage = new DecodedMessage(this.#client, message);
            asyncStream.callback(err, decodedMessage);
            callback?.(err, decodedMessage);
        });
        asyncStream.stopCallback = stream.end.bind(stream);
        return asyncStream;
    }
    async addMembers(accountAddresses) {
        return this.#group.addMembers(accountAddresses);
    }
    async addMembersByInboxId(inboxIds) {
        return this.#group.addMembersByInboxId(inboxIds);
    }
    async removeMembers(accountAddresses) {
        return this.#group.removeMembers(accountAddresses);
    }
    async removeMembersByInboxId(inboxIds) {
        return this.#group.removeMembersByInboxId(inboxIds);
    }
    async addAdmin(inboxId) {
        return this.#group.addAdmin(inboxId);
    }
    async removeAdmin(inboxId) {
        return this.#group.removeAdmin(inboxId);
    }
    async addSuperAdmin(inboxId) {
        return this.#group.addSuperAdmin(inboxId);
    }
    async removeSuperAdmin(inboxId) {
        return this.#group.removeSuperAdmin(inboxId);
    }
    async publishMessages() {
        return this.#group.publishMessages();
    }
    sendOptimistic(content, contentType) {
        if (typeof content !== "string" && !contentType) {
            throw new Error("Content type is required when sending content other than text");
        }
        const encodedContent = typeof content === "string"
            ? this.#client.encodeContent(content, contentType ?? contentTypeText.ContentTypeText)
            : this.#client.encodeContent(content, contentType);
        return this.#group.sendOptimistic(encodedContent);
    }
    async send(content, contentType) {
        if (typeof content !== "string" && !contentType) {
            throw new Error("Content type is required when sending content other than text");
        }
        const encodedContent = typeof content === "string"
            ? this.#client.encodeContent(content, contentType ?? contentTypeText.ContentTypeText)
            : this.#client.encodeContent(content, contentType);
        return this.#group.send(encodedContent);
    }
    messages(options) {
        return this.#group
            .findMessages(options)
            .map((message) => new DecodedMessage(this.#client, message));
    }
}

class Conversations {
    #client;
    #conversations;
    constructor(client, conversations) {
        this.#client = client;
        this.#conversations = conversations;
    }
    getConversationById(id) {
        try {
            // findGroupById will throw if group is not found
            const group = this.#conversations.findGroupById(id);
            return new Conversation(this.#client, group);
        }
        catch {
            return null;
        }
    }
    getMessageById(id) {
        try {
            // findMessageById will throw if message is not found
            const message = this.#conversations.findMessageById(id);
            return new DecodedMessage(this.#client, message);
        }
        catch {
            return null;
        }
    }
    async newConversation(accountAddresses, options) {
        const group = await this.#conversations.createGroup(accountAddresses, options);
        const conversation = new Conversation(this.#client, group);
        return conversation;
    }
    async list(options) {
        const groups = await this.#conversations.list(options);
        return groups.map((group) => {
            const conversation = new Conversation(this.#client, group);
            return conversation;
        });
    }
    async sync() {
        return this.#conversations.sync();
    }
    stream(callback) {
        const asyncStream = new AsyncStream();
        const stream = this.#conversations.stream((err, group) => {
            const conversation = new Conversation(this.#client, group);
            asyncStream.callback(err, conversation);
            callback?.(err, conversation);
        });
        asyncStream.stopCallback = stream.end.bind(stream);
        return asyncStream;
    }
    async streamAllMessages(callback) {
        // sync conversations first
        await this.sync();
        const asyncStream = new AsyncStream();
        const stream = this.#conversations.streamAllMessages((err, message) => {
            const decodedMessage = new DecodedMessage(this.#client, message);
            asyncStream.callback(err, decodedMessage);
            callback?.(err, decodedMessage);
        });
        asyncStream.stopCallback = stream.end.bind(stream);
        return asyncStream;
    }
}

const ApiUrls = {
    local: "http://localhost:5556",
    dev: "https://grpc.dev.xmtp.network:443",
    production: "https://grpc.production.xmtp.network:443",
};
class Client {
    #innerClient;
    #conversations;
    #codecs;
    constructor(client, codecs) {
        this.#innerClient = client;
        this.#conversations = new Conversations(this, client.conversations());
        this.#codecs = new Map(codecs.map((codec) => [codec.contentType.toString(), codec]));
    }
    static async create(accountAddress, options) {
        const host = options?.apiUrl ?? ApiUrls[options?.env ?? "dev"];
        const isSecure = host.startsWith("https");
        const dbPath = options?.dbPath ?? node_path.join(process.cwd(), `${accountAddress}.db3`);
        const inboxId = (await nodeBindings.getInboxIdForAddress(host, isSecure, accountAddress)) ||
            nodeBindings.generateInboxId(accountAddress);
        return new Client(await nodeBindings.createClient(host, isSecure, dbPath, inboxId, accountAddress, options?.encryptionKey, options?.requestHistorySync, options?.logging ?? "off"), [new GroupUpdatedCodec(), new contentTypeText.TextCodec(), ...(options?.codecs ?? [])]);
    }
    get accountAddress() {
        return this.#innerClient.accountAddress;
    }
    get inboxId() {
        return this.#innerClient.inboxId();
    }
    get installationId() {
        return this.#innerClient.installationId();
    }
    get isRegistered() {
        return this.#innerClient.isRegistered();
    }
    async signatureText() {
        try {
            const signatureText = await this.#innerClient.createInboxSignatureText();
            return signatureText;
        }
        catch (e) {
            return null;
        }
    }
    async canMessage(accountAddresses) {
        return this.#innerClient.canMessage(accountAddresses);
    }
    addSignature(signatureBytes) {
        this.#innerClient.addSignature(1 /* NapiSignatureRequestType.CreateInbox */, signatureBytes);
    }
    async registerIdentity() {
        return this.#innerClient.registerIdentity();
    }
    get conversations() {
        return this.#conversations;
    }
    codecFor(contentType) {
        return this.#codecs.get(contentType.toString());
    }
    encodeContent(content, contentType) {
        const codec = this.codecFor(contentType);
        if (!codec) {
            throw new Error(`no codec for ${contentType.toString()}`);
        }
        const encoded = codec.encode(content, this);
        const fallback = codec.fallback(content);
        if (fallback) {
            encoded.fallback = fallback;
        }
        return encoded;
    }
    decodeContent(message, contentType) {
        const codec = this.codecFor(contentType);
        if (!codec) {
            throw new Error(`no codec for ${contentType.toString()}`);
        }
        // throw an error if there's an invalid group membership change message
        if (contentType.sameAs(ContentTypeGroupUpdated) &&
            message.kind !== 1 /* NapiGroupMessageKind.MembershipChange */) {
            throw new Error("Error decoding group membership change");
        }
        return codec.decode(message.content, this);
    }
    async requestHistorySync() {
        return this.#innerClient.requestHistorySync();
    }
    async getInboxIdByAddress(accountAddress) {
        return this.#innerClient.findInboxIdByAddress(accountAddress);
    }
    async inboxState(refreshFromNetwork = false) {
        return this.#innerClient.inboxState(refreshFromNetwork);
    }
    async inboxStateFromInboxIds(inboxIds, refreshFromNetwork) {
        return this.#innerClient.addressesFromInboxId(refreshFromNetwork ?? false, inboxIds);
    }
}

exports.ApiUrls = ApiUrls;
exports.Client = Client;
exports.ContentTypeGroupUpdated = ContentTypeGroupUpdated;
exports.Conversation = Conversation;
exports.Conversations = Conversations;
exports.DecodedMessage = DecodedMessage;
exports.GroupUpdatedCodec = GroupUpdatedCodec;
//# sourceMappingURL=index.cjs.map
